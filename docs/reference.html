<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style/style.css" />
    <link rel="stylesheet" href="style/menuItem.css" />

    <!-- highlight.js -->
    <script src="style/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link rel="stylesheet" href="style/highlight-idea.css">

    <title>Jeka - Reference Guide</title>
</head>

<body>
<div class="title">Jeka - Reference Guide</div>
<br/>
<div style="color: lightslategrey; font-size: large">Author : Jérôme Angibaud</div>
<div style="color: lightslategrey; font-size: large">Version : HEAD-SNAPSHOT</div>
<br />
<a href="#Introduction" class="menuItem1">Introduction</a><br />
<a href="#Library" class="menuItem1">Library</a><br />
<a href="#Files" class="menuItem2">Files</a><br />
<a href="#System" class="menuItem2">System</a><br />
<a href="#DependencyManagement" class="menuItem2">Dependency Management</a><br />
<a href="#Concepts" class="menuItem3">Concepts</a><br />
<a href="#Whatisadependency?" class="menuItem4">What is a dependency ?</a><br />
<a href="#Whatisascope?" class="menuItem4">What is a scope ?</a><br />
<a href="#Whatisascopeddependency?" class="menuItem4">What is a scoped dependency ?</a><br />
<a href="#Defineasetofdependencies" class="menuItem3">Define a set of dependencies</a><br />
<a href="#HHierarchyofDependencyTypes." class="menuItem3">HHierarchy of Dependency Types.</a><br />
<a href="#DependenciesonModule" class="menuItem4">Dependencies on Module</a><br />
<a href="#Dependenciesonlocalfiles" class="menuItem4">Dependencies on local files</a><br />
<a href="#Dependenciesonfilesproducedbycomputation" class="menuItem4">Dependencies on files produced by computation</a><br />
<a href="#ResolveDependencies" class="menuItem3">Resolve Dependencies</a><br />
<a href="#Publication" class="menuItem3">Publication</a><br />
<a href="#PublishtoaMavenrepository" class="menuItem4">Publish to a Maven repository</a><br />
<a href="#PublishtoaIvyrepository" class="menuItem4">Publish to a Ivy repository</a><br />
<a href="#JavaProjectBuilding" class="menuItem2">Java Project Building</a><br />
<a href="#Compilation" class="menuItem3">Compilation</a><br />
<a href="#Javadoc" class="menuItem3">Javadoc</a><br />
<a href="#Classpath" class="menuItem3">Classpath</a><br />
<a href="#Javajarandmanifest" class="menuItem3">Java jar and manifest</a><br />
<a href="#Classloaders" class="menuItem3">Classloaders</a><br />
<a href="#Junittests" class="menuItem3">Junit tests</a><br />
<a href="#Projects" class="menuItem3">Projects</a><br />
<a href="#ThirdPartyToolIntegration" class="menuItem2">Third Party Tool Integration</a><br />
<a href="#Eclipse" class="menuItem3">Eclipse</a><br />
<a href="#Intellij" class="menuItem3">Intellij</a><br />
<a href="#Git" class="menuItem3">Git</a><br />
<a href="#Maven" class="menuItem3">Maven</a><br />
<a href="#ToolPart" class="menuItem1">Tool Part</a><br />
<a href="#JekaRuntime" class="menuItem2">Jeka Runtime</a><br />
<a href="#JekafromCommandline" class="menuItem3">Jeka from Command line</a><br />
<a href="#ParsetheCommandLine" class="menuItem4">Parse the Command Line</a><br />
<a href="#PopulateSystemPropertiesfromConfigurationFilesandCommandline" class="menuItem4">Populate System Properties from Configuration Files and Command line</a><br />
<a href="#Pre-process" class="menuItem4">Pre-process </a><br />
<a href="#CompileDefClasses" class="menuItem4">Compile Def Classes</a><br />
<a href="#SelectCommandSetClass" class="menuItem4">Select CommandSet Class</a><br />
<a href="#InstantiateCommandSetClass" class="menuItem4">Instantiate CommandSet Class</a><br />
<a href="#InvokeMethodsSpecifiedinJekaCommandLinearguments" class="menuItem4">Invoke Methods Specified in Jeka Command Line arguments</a><br />
<a href="#ErrorHandling" class="menuItem4">Error Handling</a><br />
<a href="#JekafromIDE" class="menuItem3">Jeka from IDE</a><br />
<a href="#IDEClasspathSetting" class="menuItem4">IDE Classpath Setting</a><br />
<a href="#LaunchfromIDE" class="menuItem4">Launch from IDE</a><br />
<a href="#Wrappermode" class="menuItem3">Wrapper mode</a><br />
<a href="#WrapperModeinMulti-Project" class="menuItem4">Wrapper Mode in Multi-Project</a><br />
<a href="#EmbeddedMode" class="menuItem3">Embedded Mode</a><br />
<a href="#DefaultPathSettings" class="menuItem3">Default Path Settings</a><br />
<a href="#SpecifyJekaUserHome" class="menuItem4">Specify Jeka User Home</a><br />
<a href="#SpecifytheLocalRepositoryCache" class="menuItem4">Specify the Local Repository Cache</a><br />
<a href="#SeeEffectivePaths" class="menuItem4">See Effective Paths</a><br />
<a href="#CommandSetParameters" class="menuItem2">CommandSet Parameters</a><br />
<a href="#EnvironmentVariables" class="menuItem3">Environment Variables</a><br />
<a href="#SystemProperties" class="menuItem3">System Properties</a><br />
<a href="#JekaOptions" class="menuItem3">Jeka Options</a><br />
<a href="#InjectOptions" class="menuItem4">Inject Options</a><br />
<a href="#RetrieveOptionsasStringValues" class="menuItem4">Retrieve Options as String Values</a><br />
<a href="#RetrieveOptionsinCommandSetClassFields" class="menuItem4">Retrieve Options in CommandSet Class Fields</a><br />
<a href="#Compositeoptions" class="menuItem4">Composite options</a><br />
<a href="#DocumentOptions" class="menuItem4">Document Options</a><br />
<a href="#Built-inOptions" class="menuItem4">Built-in Options</a><br />
<a href="#Plugins" class="menuItem2">Plugins</a><br />
<a href="#LoadPlugins" class="menuItem3">Load Plugins</a><br />
<a href="#ModifyJkCommandSetInstance" class="menuItem3">Modify JkCommandSet Instance</a><br />
<a href="#ConfigurePluginsinJkCommandSetClass" class="menuItem3">Configure Plugins in JkCommandSet Class</a><br />
<a href="#DocumentPlugins" class="menuItem3">Document Plugins</a><br />
<a href="#ImportExternalRuns" class="menuItem2">Import External Runs</a><br />
<a href="#Principle" class="menuItem3">Principle</a><br />
<a href="#DeclareRunImport" class="menuItem3">Declare Run Import</a><br />
<a href="#OptionPropagation" class="menuItem3">Option Propagation</a><br />
<a href="#Methodpropagation" class="menuItem3">Method propagation</a><br />
<a href="#AccessImportedRunsProgrammatically" class="menuItem3">Access Imported Runs Programmatically</a><br />
<a href="#SelfDocumentation" class="menuItem2">Self Documentation</a><a name="Introduction"></a>
<h1>Introduction</h1>
<p><strong>What is Jeka ?</strong></p>
<p>Jeka is both a build library and an automation tool.</p>
<p>The build library helps for dealing with file sets, compilation, dependency management, testing, publishing,
launching external processes, crypto signatures... in a glance, all regular things you need to build/publish projects and especially Java projects.
The library can be used in any Java program and does not have any dependency.</p>
<p>The tool is intended to execute Java source code from the console in a parameterizable way. Its architecture eases the
reuse of build elements (logic, settings, doc, ...) across projects.</p>
<p>Combined it provides a full feature build tool with endless possibilities of extension.</p>
<p>Although library and tool are bundled in the same jar, the library does not depend on the tool at all. It can be understood
on its own without any knowledge of the tool.</p>
<p><strong>What is this document for  ?</strong></p>
<p>This document stands for reference guide. It provides :</p>
<ul>
<li>An overview of the build library API.</li>
<li>Details about Jeka tool behaviour.</li>
</ul>
<p>If you are looking for how exactly Jeka behaves or you want to get a pretty exhaustive list of Jeka features, you are in the right place.</p>
<p>If you are looking for further details about API, please consult Javadoc or source code. Jeka source code has been
written with intelligibility in mind in order to navigate easily from the user code to the Jeka engine room.
For Java developers, reading source code and putting break points troubleshoots faster than documentation/support most of the time.</p>
<p>Jeka philosophy is to be transparent and easy to master. We hope that no user will ever feel the need to buy some
trainings or books to master it.</p>
<a name="Library"></a>
<h1>Library</h1>
<p>Jeka contains a library for all regular things you need to build/publish projects and especially Java projects.
It can be embedded in your own tool and used in a simple <code>main</code> method.</p>
<p>The Jeka core jar embeds third party jars as <em>Ivy</em> or <em>BouncyCastle</em> but these libraries are embedded in the Jeka
jar and loaded in a specific class loader. These 3rd party APIs are not visible/accessible to client code so one can
use another version of these libraries without conflict : from user point of view, Jeka is a <em>zero-dependency library</em>.</p>
<p>This is an example for building and publishing a multi-module project :</p>
<pre><code class="language-java">    // A project with ala Maven layout (src/main/java, src/test/java, ...)
    JkJavaProject coreProject = JkJavaProject.ofMavenLayout(&quot;../org.myorg.mycore&quot;);
    coreProject.addDependencies(
            JkDependencySet.of().and(&quot;junit:junit:4.11&quot;, JkJavaDepScopes.TEST));

    // Another project depending on the first project + Guava
    JkJavaProject dependerProject = JkJavaProject.ofMavenLayout(&quot;.&quot;);
    dependerProject.addDependencies(JkDependencySet.of()
            .and(&quot;com.google.guava:guava:22.0&quot;)
            .and(coreProject));

    dependerProject.getMaker().clean().makeAllArtifacts();  // generate source and binary jars
    dependerProject.getMaker().getTasksForPublishing().publish(); // Publish artifacts on the default binary repository 
</code></pre>
<p>Above code defines two projects, one depending on the other : building the depender project implies building the core project if not already done.</p>
<p><span class="menuItem0">API Style</span></p>
<p><em>Jeka</em> tries to stick with a consistent API design style.</p>
<p><strong>Class and Interface Naming Convention</strong></p>
<p>All Jeka public classes/interfaces starts with <code>Jk</code>. The reason is easing distinction in IDE between classes supposed be used
in production or test and the ones used for building.</p>
<p><strong>Mutable Vs Immutable</strong></p>
<p>As a rule of thumb <em>Jeka</em> favors immutable objects. Nevertheless when object structure is getting deep, immutability
makes object cumbersome to configure, that's why objects of the API with deep structure are mutable while simpler are
immutable.</p>
<p><strong>Instantiation</strong></p>
<p>All objects are instantiated using static factory methods. Every factory method names start with <code>of</code>.</p>
<p><strong>Read Accessors</strong></p>
<p>All accessor method names (methods returning a result without requiring IO, only computation) starts with <code>get</code>.</p>
<p><strong>Withers/Anders for Immutable Objects</strong></p>
<p>To create a subtly different object from an other immutable one, <em>Jeka</em> provides :</p>
<ul>
<li>Methods starting with <code>with</code> when a property is to be replaced by another.</li>
<li>Methods starting with <code>and</code> when a collection property is to be replaced by the same one plus an extra element.</li>
<li>Methods starting with <code>minus</code> when a collection property is to be replaced by the same one minus a specified element.</li>
</ul>
<p><strong>Setters/Adders for Mutable Objects</strong></p>
<p>To modify a mutable object, <em>Jeka</em> provides :</p>
<ul>
<li>Methods starting with <code>set</code> to replace a single property value by an other.</li>
<li>Methods starting with <code>add</code> to add a value to a collection property.
Those methods returns the object itself for chaining.</li>
</ul>
<p><strong>Translators</strong></p>
<p>To translate an object to another representation (for example a <code>JkDependencySet</code> to a  list of <code>JkScopedDependency</code>)
<em>Jeka</em> provides methods starting with <code>to</code>.</p>
<p><span class="menuItem0">Domains Covered by the API</span></p>
<p>The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API
relies on other lower level ones provided by <em>Jeka</em>. In a glance these are the domains covered by the <em>Jeka</em> APIs :</p>
<ul>
<li><strong>Files :</strong> File trees, filters, zip, path sequence</li>
<li><strong>System :</strong> Launching external process, Logging, Meta-info</li>
<li><strong>Cryptography :</strong> PGP signer</li>
<li><strong>Dependency management :</strong> Dependency management, publishing on repositories</li>
<li><strong>Java :</strong> Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching
<ul>
<li><strong>Junit :</strong> Launching, report</li>
<li><strong>Project :</strong> Project structure to build</li>
</ul>
</li>
<li><strong>Tooling :</strong> Eclipse integration, intellij integration, Maven interaction, Git</li>
<li><strong>Support :</strong> Set of utility class with static methods to handle low-level concerns</li>
</ul>
<a name="Files"></a>
<h2>Files</h2>
<p>File manipulation is a central part of building software.
Jeka embraces JDK7 <em>java.nio.file</em> API by adding some concept around to provide a powerful fluent style API to performing
recurrent tasks with minimal effort.</p>
<p>The following classes lie in <code>dev.jeka.core.api.file</code> package :</p>
<ul>
<li><code>JkPathFile</code> : A simple wrapper around  for file (not folder) with copy, content interpolation,
checksum, deletion, creation features.</li>
</ul>
<p>The following snippet creates a file and fill it the content of the specified url.</p>
<pre><code class="language-java">JkPathFile.of(&quot;config/my-config.xml&quot;).createIfNotExist().replaceContentBy(&quot;http://myserver/conf/central.xml&quot;);
</code></pre>
<ul>
<li><code>JkPathSequence</code> : A list of <code>java.nio.file.Path</code>.</li>
</ul>
<p>Instances of this class are returned by dependency manager to turn a set of dependency into a resolved classpath.</p>
<ul>
<li><code>JkPathMatcher</code> : A <code>java.nio.file.PathMatcher</code> based on <code>java.nio.file</code> glob pattern or regerxp.</li>
</ul>
<p>Used by <code>JkPathTree</code> to filter in/out files according name patterns.</p>
<ul>
<li><code>JkPathTree</code> : A root folder (or a zip file) along a <code>PathMatcher</code> providing operations to copy, navigate, zip or iterate.
This central class is spread all over Jeka APIs.</li>
</ul>
<p>The following snippet copies all non java source files to another directory preserving structure.</p>
<pre><code class="language-java">JkPathTree.of(&quot;src&quot;).andMatching(false, &quot;**/*.java&quot;).copyTo(&quot;build/classes&quot;);
</code></pre>
<ul>
<li><code>JkPathTreeSet</code> : A set of <code>JkPathTree</code>.</li>
</ul>
<p>Instances of this class are used by Java project api to defines source and resource files. It also helps to create fat jars.</p>
<ul>
<li><code>JkResourceProcessor</code> : Provides a means to copy a set of files, preserving the structure and
replacing some text by other text. Typically used for replacing token as <code>${server.ip}</code> by concrete value.</li>
</ul>
<pre><code class="language-java">Map&lt;String, String&gt; varReplacement = new HashMap&lt;&gt;();
varReplacement.put(&quot;${server.ip}&quot;, &quot;123.211.11.0&quot;);
varReplacement.put(&quot;${server.port}&quot;, &quot;8881&quot;);
JkResourceProcessor.of(JkPathTreeSet.of(Paths.get(&quot;src&quot;))).andInterpolate(&quot;**/*.properties&quot;, varReplacement)
    .generateTo(Paths.get(&quot;build/classes&quot;), Charset.forName(&quot;UTF-8&quot;));
</code></pre>
<a name="System"></a>
<h2>System</h2>
<p>The <code>dev.jeka.core.api.system</code> package provides system level functions :</p>
<ul>
<li>
<p><code>JkException</code> : Marker exception generally to mention user misuse.</p>
</li>
<li>
<p><code>JkInfo</code> : Provides meta information as the running version of Jeka.</p>
</li>
<li>
<p><code>JkLocator</code> : Provides information about where is located repository cache or Jeka user home.</p>
</li>
<li>
<p><code>JkLog</code> : Provides API to log Jeka event. It supports hierarchical logs through <code>#startTask</code>
and <code>#endtask</code> methods.</p>
</li>
<li>
<p><code>JkProcess</code> : Launcher for external process.</p>
</li>
</ul>
<a name="DependencyManagement"></a>
<h2>Dependency Management</h2>
<a name="Concepts"></a>
<h3>Concepts</h3>
<a name="Whatisadependency?"></a>
<h4>What is a dependency ?</h4>
<p>For Jeka, a <em>dependency</em> is something that can be resolved to a set of files by a <code>JkDependencyResolver</code>.
Generally a dependency is resolved to 1 file (or forlder) but it can be 0 or many.</p>
<p>A dependency is always an instance of <code>JkDependency</code>.</p>
<p>Jeka distinguishes 3 types of dependency :</p>
<ul>
<li><strong>Arbitrary files</strong> located on the file system (represented by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system when the build is running.</li>
<li><strong>Files produced by a computation</strong> (represented by <code>JkComputedDependency</code> class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project.</li>
<li><strong>Reference to module</strong> (represented by <code>JkModuleDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and resolve transitively any artifact located in a repository as you would do with Maven, Ivy or Gradle.</li>
</ul>
<p>For the last, Jeka is using <em>Ivy 2.5.0</em> under the hood.
This library is embedded inside the Jeka jar and is executed in a dedicated classloader.
So all happens as if there where no dependency at all.</p>
<a name="Whatisascope?"></a>
<h4>What is a scope ?</h4>
<p>Projects may need dependencies to accomplish certain tasks and these dependencies may vary according the executed tasks.
For example, to <em>compile</em> you may need <em>guava</em> library only but to <em>test</em> you'll need <em>junit</em> library too.
To tag dependencies according their usage, Jeka uses the notion of <em>scope</em> (represented by <code>JkScope</code> class). This notion is similar to the Maven scope.</p>
<p>A scope can <em>inherit</em> from one or several scopes. This means that if a scope <em>Foo</em> inherits from scope <em>Bar</em> then a dependencies declared with scope <em>Bar</em> will be also considered as declared with scope <em>Foo</em>.
For instance, in <code>JkJavaBuild</code>, scope <code>TEST</code> inherits from <code>RUNTIME</code> that inherits from <code>COMPILE</code> so every dependencies declared with scope <code>COMPILE</code> are considered to be declared with scope <code>RUNTIME</code> and <code>TEST</code> as well.</p>
<p>By default, scopes are <em>transitive</em>. This has only a meaning for <em>module dependencies</em>.
If we have 3 modules having the following dependency scheme : <code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> and the <code>A</code>-&gt; <code>B</code> dependency is declared with a <em>non transitive scope</em>, then <code>A</code> won't depend from <code>C</code>.</p>
<p><code>JkJavaDepScope</code> class pre-defines scopes used in Java projects.</p>
<p><strong>Scope Mapping</strong> : Projects consuming artifacts coming from Ivy repository can also use <code>JkScopeMapping</code> which is more powerful.
This notion maps strictly to the <a href="http://ant.apache.org/ivy/history/2.2.0/ivyfile/configurations.html">Ivy configuration</a> concept.</p>
<a name="Whatisascopeddependency?"></a>
<h4>What is a scoped dependency ?</h4>
<p>A <em>scoped dependency</em> (represented by <code>JkScopedDependency</code> class) is simply a dependency associated with zero, one or many scopes.</p>
<a name="Defineasetofdependencies"></a>
<h3>Define a set of dependencies</h3>
<p>To define a set of dependencies (typically the dependencies of the project to build), you basically define a set of <em>scoped dependencies</em>.</p>
<p>The set of scoped dependencies concept is represented by <code>JkDependencySet</code> class. This class provides a fluent API for easier instantiation.</p>
<pre><code class="language-Java">import static dev.jeka.core.api.depmanagement.JkJavaDepScopes.*;
...
JkDependencySet deps = JkDependencySet.of()
    .and(&quot;com.google.guava&quot;) 
    .and(&quot;org.slf4j:slf4j-simple&quot;)
    .and(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
    .and(&quot;junit:junit:4.11&quot;, TEST)
    .and(&quot;org.mockito:mockito-all:1.9.5&quot;, TEST)
    .andFile(&quot;../libs.myjar&quot;)
    .withVersionProvider(myVersionProvider)
    .withDefaultScopes(COMPILE);
</code></pre>
<p>Note that :</p>
<ul>
<li>
<p>Module version and scopes can be omitted when declaring dependencies. Versions can be provided by a <code>JkVersionProvider</code>
and scopes can be defaulted.</p>
</li>
<li>
<p>Instances of <code>JkDependencySet</code> can be combined together in order to construct large dependencySet from smaller ones.</p>
</li>
<li>
<p><code>JkDependencySet#ofTextDescription</code> provides a mean to instantiate a dependency set from a simple text as :</p>
</li>
</ul>
<pre><code>- COMPILE RUNTIME
org.springframework.boot:spring-boot-starter-thymeleaf
org.springframework.boot:spring-boot-starter-data-jpa

- RUNTIME
com.h2database:h2
org.liquibase:liquibase-core
com.oracle:ojdbc6:12.1.0

- TEST
org.springframework.boot:spring-boot-starter-test
org.seleniumhq.selenium:selenium-chrome-driver:3.4.0
org.fluentlenium:fluentlenium-assertj:3.2.0
org.fluentlenium:fluentlenium-junit:3.2.0

- PROVIDED
org.projectlombok:lombok:1.16.16
</code></pre>
<a name="HHierarchyofDependencyTypes."></a>
<h3>HHierarchy of Dependency Types.</h3>
<ul>
<li><code>JkModuleDependency</code> : Dependency on Maven modules</li>
<li><code>JkFileDependency</code> (Abstract): Dependency on files to be found on file system
<ul>
<li><code>JkComputedDependency</code> : Dependency on files produced by the execution of a <code>Runnable</code>.</li>
<li><code>JkFileSystemDependency</code> : Dependency on files supposed to already exist on file system.</li>
</ul>
</li>
</ul>
<a name="DependenciesonModule"></a>
<h4>Dependencies on Module</h4>
<p>This is for declaring a dependency on module hosted in <em>Maven</em> or <em>Ivy</em> repository. Basically you instantiate a <code>JkModuleDepency</code> from it's group, name and version.</p>
<pre><code class="language-Java">    JkDependencySet.of()
        .and(JkPopularModule.GUAVA, &quot;18.0&quot;)
        .and(&quot;com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[&quot;)
        .and(&quot;mygroup:mymodule:myclassifier:0.2-SNAPSHOT&quot;);
</code></pre>
<p>There is many way to indicate a module dependency, see Javadoc for browsing possibilities.</p>
<p>Note that :</p>
<ul>
<li>A version ending by <code>-SNAPSHOT</code> has a special meaning : Jeka will consider it <em>&quot;changing&quot;</em>. This means that it won't cache it locally and will download the latest version from repository.</li>
<li>As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned <a href="http://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html">here</a>.</li>
<li>Dependency files are downloaded in <em>[USER HOME]</em>/.jeka/cache/repo</li>
</ul>
<a name="Dependenciesonlocalfiles"></a>
<h4>Dependencies on local files</h4>
<p>You just have to mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails.</p>
<pre><code class="language-Java">    JkDependencySet of()
        .andFile(&quot;libs/my.jar&quot;)
        .andFile(&quot;libs/my.testingtool.jar&quot;, TEST);
    }
		
</code></pre>
<a name="Dependenciesonfilesproducedbycomputation"></a>
<h4>Dependencies on files produced by computation</h4>
<p>It is typically used for <em>multi-modules</em> or <em>multi-techno</em> projects.</p>
<p>The principle is that if the specified files are not found, then the computation is run in order to generate the missing files.
If some files still missing after the computation has run, the build fails.</p>
<p>This mechanism is quite simple yet powerful as it addresses following use cases :</p>
<ul>
<li>Dependencies on files produced by an artifact producer (<code>JkArtifactProducer</code>). A Jeka Java project is an artifact producer.</li>
<li>Dependencies on files produced by external project built with any type of technology (Ant, Grunt, Maven, Gradle, SBT, Android SDK, Make, ...).</li>
<li>Dependencies on files produced by any means.</li>
</ul>
<p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p>
<p>The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with
<em>Jeka</em>.</p>
<pre><code class="language-Java">Path mavenProject = Paths.get(&quot;../a-maven-project&quot;);
JkProcess mavenBuild = JkProcess.of(&quot;mvn&quot;, &quot;clean&quot;, &quot;install&quot;).withWorkingDir(mavenProject);
Path mavenProjectJar = mavenProject.resolve(&quot;target/maven-project.jar&quot;);
JkJavaProject externalProject = JkJavaProject.ofSimple(Paths.get(&quot;../a-jeka-project&quot;)); 
JkDependencySet deps = JkDependencySet.of()
    .and(JkComputedDependency.of(mavenBuild, mavenProjectJar))
    .and(externalProject);
</code></pre>
<a name="ResolveDependencies"></a>
<h3>Resolve Dependencies</h3>
<p>The <code>JkDependencyResolver</code> class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning <code>JkResolveResult</code> from a
<code>JkdependencySet</code>.</p>
<pre><code class="language-java">JkDependencySet deps =  JkDependencySet
                            .of(&quot;org.apache.httpcomponents:httpclient:4.5.3&quot;)
                            .andFile(&quot;libs/my.jar&quot;);

// Module dependencies are fetched from Maven central repo
JkDependencyResolver resolver = JkDependencyResolver.of(JkRepo.ofMavenCentral());  
JkResolveResult result = resolver().resolve(deps);
</code></pre>
<p>From the result you can :</p>
<ul>
<li>Navigate in the resolved dependency tree as :</li>
</ul>
<pre><code class="language-java">JkDependencyNode slfjApiNodeDep = result.getDependencyTree().getFirst(JkModuleId.of(&quot;org.slf4j:slf4j-api&quot;));
System.out.println(slfjApiNode.getModuleInfo().getResolvedVersion());
</code></pre>
<ul>
<li>Get the direct list of artifact files</li>
</ul>
<pre><code class="language-java">JkPathSequence sequence = result.getFiles();  
sequence.forEach(System.out::println); // print each files part of the dependency resolution
</code></pre>
<ul>
<li>Resolve for a given scope</li>
</ul>
<p>The following snippets captures the resolved dependency files for COMPILE scope. Junit is excluded from this result.</p>
<pre><code>JkDependencySet deps = JkDependencySet.of()
    .and(&quot;org.slf4j:slf4j-simple&quot;, COMPILE_AND_RUNTIME)
    .and(&quot;junit:junit:4.11&quot;, TEST);
    
Iterable&lt;Path&gt; files = JkDependencyResolver.of(JkRepo.ofMavenCentral()).resolve(COMPILE).getFiles();
</code></pre>
<a name="Publication"></a>
<h3>Publication</h3>
<p>Jeka is able to publish on both Maven and Ivy repository. This includes repositories as <a href="http://www.sonatype.org/nexus/">Sonatype Nexus</a> or <a href="http://www.jfrog.com/artifactory/">Jfrog Artifactory</a>.</p>
<p>Maven and Ivy have different publication model, so Jeka proposes specific APIs according you want to publish on a Maven or Ivy repository.</p>
<a name="PublishtoaMavenrepository"></a>
<h4>Publish to a Maven repository</h4>
<p>Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according
provided elements.</p>
<p>The following snippet demonstrate a pretty sophisticated publishing on Maven :</p>
<pre><code class="language-java">    JkVersionedModule versionedModule = JkVersionedModule.of(&quot;org.myorg:mylib:1.2.6&quot;);
    JkDependencySet deps = JkDependencySet.of()
            .and(&quot;org.slf4j:slf4j-simple&quot;, COMPILE_AND_RUNTIME)
            .and(&quot;junit:junit:4.11&quot;, TEST);
    JkMavenPublication mavenPublication = JkMavenPublication.of(Paths.get(&quot;org.myorg.mylib.jar&quot;))

            // the following are optional but required to publish on public repositories.
            .and(Paths.get(&quot;org.myorg.mylib-sources.jar&quot;), &quot;sources&quot;)
            .and(Paths.get(&quot;org.myorg.mylib-javadoc.jar&quot;), &quot;javadoc&quot;)
            .withChecksums(&quot;sha-2&quot;, &quot;md5&quot;)
            .withSigner(JkPgp.of(Paths.get(&quot;myPubring&quot;), Paths.get(&quot;mySecretRing&quot;), &quot;mypassword&quot;))
            .with(JkMavenPublicationInfo.of(&quot;My sample project&quot;,
                    &quot;A project to demonstrate publishing on Jeka&quot;,
                    &quot;http://project.jeka.org&quot;)
                    .andApache2License()
                    .andDeveloper(&quot;djeang&quot;, &quot;myemail@gmail.com&quot;, &quot;jeka.org&quot;, &quot;http://project.jeka.org/&quot;));

    // A complex case for repo (credential + signature + filtering) 
    JkRepo repo = JkRepo.of(&quot;http://myserver/myrepo&quot;)
            .withOptionalCredentials(&quot;myUserName&quot;, &quot;myPassword&quot;)
            .with(JkRepo.JkPublishConfig.of()
                        .withUniqueSnapshot(false)
                        .withNeedSignature(true)
                        .withFilter(mod -&gt; // only accept SNAPSHOT and MILESTONE
                            mod.getVersion().isSnapshot() || mod.getVersion().getValue().endsWith(&quot;MILESTONE&quot;)
                        ));
    
    // Actually publish the artifacts
    JkPublisher publisher = JkPublisher.of(repo);
    publisher.publishMaven(versionedModule, mavenPublication, deps);
</code></pre>
<p>Notice that Jeka allows to :</p>
<ul>
<li>Publish more than one artifact.</li>
<li>Produce &amp; publish checksum files for each published artifact.</li>
<li>Mention to use unique snapshot (<a href="http://stackoverflow.com/questions/1243574/how-to-stop-maven-artifactory-from-keeping-snapshots-with-timestamps">What is it ?</a>).</li>
<li>Feed generated pom with data necessary to publish on <a href="https://maven.apache.org/guides/mini/guide-central-repository-upload.html">central repository</a>.</li>
<li>Sign published artifact with PGP</li>
<li>Publish to multiple repository by creating the publisher using a <code>JkRepoSet</code> instead of a <code>JkRepo</code>.</li>
</ul>
<p>To sign with PGP, no need to have PGP installed on Jeka machine. Jeka uses <a href="https://www.bouncycastle.org/">Bouncy Castle</a> internally to sign artifacts.</p>
<a name="PublishtoaIvyrepository"></a>
<h4>Publish to a Ivy repository</h4>
<p>Publishing on Ivy repo is pretty similar than on Maven though there is specific options to Ivy.</p>
<pre><code class="language-java">    JkVersionedModule versionedModule = JkVersionedModule.of(&quot;org.myorg:mylib:1.2.6-SNAPSHOT&quot;);
    JkDependencySet deps = JkDependencySet.of()
            .and(&quot;org.slf4j:slf4j-simple&quot;, COMPILE_AND_RUNTIME)
            .and(&quot;junit:junit:4.11&quot;, TEST);

    JkIvyPublication publication = JkIvyPublication.of(Paths.get(&quot;org.myorg.mylib.jar&quot;), &quot;master&quot;)
            .and(Paths.get(&quot;org.myorg.mylib-sources.jar&quot;));

    JkRepo repo = JkRepo.ofIvy(Paths.get(&quot;ivyrepo&quot;));

    JkPublisher publisher = JkPublisher.of(repo);
    publisher.publishIvy(versionedModule, publication, deps, JkJavaDepScopes.DEFAULT_SCOPE_MAPPING,
            Instant.now(), JkVersionProvider.of());
</code></pre>
<a name="JavaProjectBuilding"></a>
<h2>Java Project Building</h2>
<p>Jeka provides API for processing usual Java build tasks. To illustrate this, let's start from the following
layout :</p>
<pre><code class="language-java">    Path src = getBaseDir().resolve(&quot;src/main/java&quot;);
    Path buildDir = getBaseDir().resolve(&quot;build/output&quot;);
    Path classDir = getOutputDir().resolve(&quot;classes&quot;);
    Path jarFile = getOutputDir().resolve(&quot;jar/&quot; + getBaseTree().getRoot().getFileName() + &quot;.jar&quot;);
    JkClasspath classpath = JkClasspath.of(getBaseTree().andAccept(&quot;libs/**/*.jar&quot;).getFiles());
    Path reportDir = buildDir.resolve(&quot;junitRreport&quot;);
</code></pre>
<a name="Compilation"></a>
<h3>Compilation</h3>
<p><code>JkJavaCompiler</code> stands for the compiler binary or tool while <code>JkJavaCompileSpec</code> stands for what to compile and how.</p>
<pre><code class="language-java">JkJavaCompiler.ofJdk().compile(JkJavaCompileSpec.of()
                .setOutputDir(classDir)
                .setClasspath(classpath)
                .setSourceAndTargetVersion(JkJavaVersion.V8)
                .addSources(src));
</code></pre>
<p><code>JkJavaCompiler.ofJdk()</code> provides the compiler embedded with the JDK without forking the process. It is possible to fork
it or choose an external compiler for cross-compile purpose.</p>
<a name="Javadoc"></a>
<h3>Javadoc</h3>
<p>Simple Javadoc tasks can be performed using <code>JkJavadocMaker</code> class.</p>
<pre><code class="language-java">JkJavadocMaker.of(JkPathTreeSet.of(src), buildDir.resolve(&quot;javadoc&quot;)).process();
</code></pre>
<a name="Classpath"></a>
<h3>Classpath</h3>
<p>Jeka provides <code>JkClasspath</code> to construct and reason about classpath.</p>
<pre><code class="language-java">JkClasspath classpath = JkUrlClassLoader.ofCurrent().getFullClasspath();
Path guavaJar = classpath.getEntryContainingClass(&quot;com.google.common.base.Strings&quot;);
</code></pre>
<a name="Javajarandmanifest"></a>
<h3>Java jar and manifest</h3>
<p><code>JkpathTree</code> class help to produce simply jar files using <code>zipTo</code> method :  <code>JkPathTree.of(classDir).zipTo(jarFile)</code></p>
<p>Nevertheless <code>JkJarPacker</code> along <code>JkManifest</code> provides powerful methods to read/write/edit manifests and create fat jars.</p>
<pre><code class="language-java">JkManifest.ofEmpty().addMainClass(&quot;RunClass&quot;).writeToStandardLocation(classDir);
</code></pre>
<a name="Classloaders"></a>
<h3>Classloaders</h3>
<p><code>JkClassloader</code> provides utility methods to reason about classloaders and to invoke methods coming from class loaded
in other classloader than the current one.</p>
<p><code>JkUrlClassloader</code> provides classpath scanning functions.</p>
<a name="Junittests"></a>
<h3>Junit tests</h3>
<p>The following snippet shows how to launch Junit tests programmatically.</p>
<pre><code class="language-java">   JkUnit.of().withForking()
        .withReportDir(reportDir)
        .withReport(JunitReportDetail.FULL)
        .run(classpath, JkPathTree.of(testClassDir).andAccept(&quot;**/*Test.class&quot;, &quot;*Test.class&quot;) ));
</code></pre>
<a name="Projects"></a>
<h3>Projects</h3>
<p>Projects are file structures for hosting Java projects meaning source code, test codes, dependencies,
build instructions ...</p>
<p>From a project definition, one can easily build it and produce artifacts and test executions.</p>
<pre><code class="language-java">   JkJavaProject coreProject = JkJavaProject.ofMavenLayout(&quot;./projects/core&quot;);
    coreProject.addDependencies(
            JkDependencySet.of().and(&quot;junit:junit:4.11&quot;, JkJavaDepScopes.TEST));

    // A project depending on the first project + Guava
    JkJavaProject dependerProject = JkJavaProject.ofMavenLayout(&quot;.project/depender&quot;);
    dependerProject.setVersionedModule(&quot;mygroup:depender&quot;, &quot;1.0-SNAPSHOT&quot;);
    dependerProject.addDependencies(JkDependencySet.of()
            .and(&quot;com.google.guava:guava:22.0&quot;)
            .and(coreProject));

    coreProject.getMaker().clean();
    dependerProject.getMaker().clean().makeAllArtifacts();  // create depender.jar project along core.jar
    dependerProject.getMaker().getTasksForPublishing().publish();  // publish depender.jar on default binary repository
</code></pre>
<p>The principle is that each <code>JkJavaProject</code> holds a <code>JkJavaProjectMaker</code> responsible to achieved build tasks. The <em>maker</em>
object defines atifacts to build. By default it defines <em>jar</em> and <em>sources</em> jar but it's a one liner to add <em>javadoc</em>
artifact as well.</p>
<p>You can define your onw specific artifact (distrib, binary specific,...). When defined, this artifact will be built and
deployed along the other ones.</p>
<p>JkJavaProject instances are highly configurable. You can tune your project structure/build without limits.</p>
<a name="ThirdPartyToolIntegration"></a>
<h2>Third Party Tool Integration</h2>
<p>The <code>dev.jeka.core.api.tooling</code> package provides integration with tools developers generally deal with.</p>
<a name="Eclipse"></a>
<h3>Eclipse</h3>
<p><code>JkEclipseClasspathGenerator</code> and <code>JkEclipseProjectGenerator</code> provides method to generate a proper .classpath and .project file respectively.</p>
<p><code>JkEclipseClasspathApplier</code> reads information from a .classpath file.</p>
<a name="Intellij"></a>
<h3>Intellij</h3>
<p><code>JkIntellijImlGenerator</code> generates proper .iml files.</p>
<a name="Git"></a>
<h3>Git</h3>
<p><code>JkGitWrapper</code> wraps common Git commands in a lean API.</p>
<a name="Maven"></a>
<h3>Maven</h3>
<p><code>JkMvn</code> wraps Maven command line in a lean API while <code>JkPom</code> reads POM/BOM to extract information from
as declared dependencies, dependency management, repos, properties, version and artifactId.</p>
<a name="ToolPart"></a>
<h1>Tool Part</h1>
<p><span class="menuItem0">Lexical</span></p>
<p>The following concepts are used all over the tool section :</p>
<p><strong>[PROJECT DIR]</strong> : Refers to the root folder of the project to build (or to run commands on). This is where you would put pom.xml or build.xml files.</p>
<p><strong>[JEKA HOME]</strong> : Refers to the folder where Jeka is installed. You should find <em>jeka.bat</em> and <em>jeka</em> shell scripts at the root of this folder.</p>
<p><strong>[JEKA USER HOME]</strong> : Refers to the folder where Jeka stores caches, binary repository and global user configuration. By default it is located at [USER DIR]/.jeka.</p>
<p><strong>Def Classes :</strong> Java source files located under <em>[PROJECT DIR]/jeka/def</em>. They are compiled on the flight by Jeka when invoked from the command line.</p>
<p><strong>Def Classpath :</strong> Classpath on which depends <em>def classes</em> to get compiled and <em>commandSet classes</em> to be executed.
By default, it consists in <em>Jeka</em> core classes. it can be augmented with any third party lib or def Classpath coming
from another project.
Once <em>def classes</em> sources have been compiled, <em>def Classpath</em> is augmented with their <em>.class</em> counterpart.</p>
<p><strong>CommandSet Classes :</strong> Classes extending <code>JkCommandSet</code>. Their <em>commands</em> can be invoked from the command line and
their pubic fields set from the command line as well. Generally <em>def classes</em> contains one <em>commandSet class</em> though there can be many or
none. CommandSet class can be a <em>def class</em> but can also be imported from a library or external project.</p>
<p><strong>Commands :</strong> Java methods member of <em>commandSet classes</em> and invokable from Jeka command line.
They must be instance method (not static), public, zero-args and returning void. Every method verifying these constraints is considered as a <em>command</em>.</p>
<p><strong>Options :</strong> This is a set of key-value used to inject parameters. Options can be mentioned
as command line arguments, stored in specific files or hard coded in <em>commandSet classes</em>.</p>
<p><span class="menuItem0">In a Glance</span></p>
<p>The Jeka tool consists in an engine able to run Java/Kotlin source code or compiled code from the command line.</p>
<p>Generally this code is intended to build Java projects but it can be used for any purpose.</p>
<p>In practice, your project has a structure respecting the following layout :</p>
<pre><code>[Project Dir]
   |
   + jeka
      + boot             &lt;-------- Put extra jars here to augment def Classpath.
      + def
         + MyCommands.java   &lt;----- Class extending JkCommandSet
         + MyUtility.java    &lt;---- Utility class consumed by MyCommands
         + OtherUtility.kt   &lt;---- Kotlin code is also accepted
      + output              &lt;---- Build artifacts are generated here
   + src
      + main
          + java
          + resources
   + ...
</code></pre>
<p>A <em>command class</em> may look like :</p>
<pre><code class="language-Java">import dev.jeka.core.tool.JkCommandSet;import dev.jeka.core.tool.JkDefClasspath;import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.GetMethod;
import dev.jeka.core.tool.JkDoc;
import com.google.common.base.MoreObjects;

@JkDefClasspath(&quot;commons-httpclient:commons-httpclient:3.1&quot;)  // Imports 3rd party library to be used by def classes
@JkDefClasspath(&quot;com.google.guava:guava:21.0&quot;)
public class MyCommands extends JkCommandSet {    // The command class
    
    public String myParam1 = &quot;myDefault&quot;;    // Overridable by injecting options in command line

    @JkDoc(&quot;Performs some tasks using http client&quot;)    // Only for self documentation purpose
    public void myMethod1() {                   // Run method (callable from command line)
        HttpClient client = new HttpClient();
        GetMethod getMethod = new GetMethod(&quot;http://my.url/&quot; + myParam1);
        ....
    }
    
    public void myMethod2() {   // An other run method 
        MyUtility.soSomething();
        ...
    }

}
</code></pre>
<p>From <strong>[Project Dir]</strong>,  you can invoke any command method defined on <code>MyCommands</code> class from the command line.</p>
<p>For example, executing <code>jeka myMethod1 myMethod2 -myParam1=foo</code> does the following :</p>
<ol>
<li>compile sources located in <em>jeka/def</em> directory,</li>
<li>instantiate a <code>MyCommands</code> instance,</li>
<li>inject <em>&quot;foo&quot;</em> in the <code>myParam1</code> field,</li>
<li>invoke <code>myMethod1()</code>,</li>
<li>invoke <code>myMethod2()</code>.</li>
</ol>
<p>If no <em>command class</em> are present in <em>def classes</em>, Jeka picks <code>JkCommandSet</code>. In despite this class
does not provide any particular methods, you can still perform full Java builds by invoking built-in 'java' plugin.
For such, execute <code>jeka clean java#pack</code> (<a href="#Plugins">See Plugins</a>).</p>
<p>Executing <code>jeka</code> or <code>jeka help</code> on command line displays all run methods and options for the current <em>command class</em>.</p>
<p>The following chapters detail about how the mechanism works and what you can do with.</p>
<a name="JekaRuntime"></a>
<h2>Jeka Runtime</h2>
<p>This chapter describes how to use Jeka with command line and mostly what happens behind the cover when Jeka is run.</p>
<p>Jeka is a pure Java application requiring JDK version 8 or higher (tested until 12). JDK is required and JRE is not sufficient as Jeka uses the JDK tools to compile <em>def classes</em>.</p>
<p>Jeka commands can be launched from both command line and your IDE.</p>
<a name="JekafromCommandline"></a>
<h3>Jeka from Command line</h3>
<p>To ease launching Java processes from command line, Jeka provides shell scripts ( <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/META-INF/bin/jeka.bat">jeka.bat</a> for Windows
and <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/META-INF/bin/jeka">jeka</a> for Unix ). They are located at root
of <em>[JEKA HOME]</em>. <em>[JEKA HOME]</em> is supposed to be in your PATH environment variable.</p>
<p>This script does the following :</p>
<ol>
<li>Find the <em>Java</em> executable path : Look first at <code>JEKA_JDK</code> environment variable then <code>JAVA_HOME</code>. If no such variables are  defined it takes the one lying in this JDK, otherwise it takes the one accessible in the <em>PATH</em> of your OS. <code>JEKA_JDK/bin/java</code> or <code>JAVA_HOME/bin/java</code> must resolve to the <em>Java</em> executable.</li>
<li>Get java execution option : If an environment variable <code>JEKA_OPTS</code> exists then its value is passed to the <code>java</code> command line parameters.</li>
<li>Get the classpath in the following order :
<ul>
<li>all jar and zip files found under <em>[WORKING DIR]/jeka/boot</em></li>
<li>the <em>[JEKA_HOME]/dev.jeka.jeka-core.jar</em> file</li>
</ul>
</li>
<li>Run the <em>java</em> process for launching <code>Main</code> class passing the command line argument as is. This class main method does the following :
<ol>
<li>Parse the command line.</li>
<li>Populate system properties from configuration files and command line.</li>
<li>Pre-process <em>def classes</em> . In this step, <em>def class</em> code is parsed to detect 3rd party and external project imports. Imports are added to the <em>def classpath</em>.</li>
<li>Compile <em>def classes</em> using the classpath computed in previous step.</li>
<li>Select the <em>command class</em> to be run.</li>
<li>Instantiate selected <em>command class</em>, inject options and bind plugins on it.</li>
<li>Invoke methods specified in command line arguments : methods are executed in the order they appear on the command line.</li>
</ol>
</li>
</ol>
<p>The following sub-sections detail about these steps.</p>
<a name="ParsetheCommandLine"></a>
<h4>Parse the Command Line</h4>
<p>Jeka parses the command line and processes each arguments according the following pattern :</p>
<ul>
<li>
<p><strong>Argument starts with <code>@</code> :</strong> This is a library import clause : the text just next to, is added to the <em>def Classpath</em>.
For example <code>jeka myMethod @dev.jeka:an-extra-plugin:3.3</code> augments the <em>def Classpath</em> with the <em>an-extra-Plugin</em> jar.
This is similar to annotate a <em>def class</em> with <code>@JkDefClasspath(&quot;dev.jeka:an-extra-plugin:3.3&quot;)</code>.
This is intended to modifiate behavior of <em>command class</em> by plugins dynamically.</p>
</li>
<li>
<p><strong>Argument starts with <code>-</code> :</strong> This is an option declaration. The content following is is expected to be formatted as <em>optionName=optionValue</em>.
For example, `-repo.run.url=http://my.repo.milestone/' will inject 'http://my.repo.milestone/' in the 'repo.run.url' Jeka option.</p>
</li>
<li>
<p><strong>In other cases :</strong> argument is considered as a run method name to be invoked on the <em>command class</em> instance.</p>
</li>
</ul>
<a name="PopulateSystemPropertiesfromConfigurationFilesandCommandline"></a>
<h4>Populate System Properties from Configuration Files and Command line</h4>
<p>Jeka loads system properties in order from :</p>
<ul>
<li><em>[JEKA HOME]</em>/system.properties</li>
<li><em>[JEKA USER HOME]</em>/system.properties</li>
<li>command line parsed above</li>
</ul>
<p>The last loaded properties override the previous ones if there is some conflicts.</p>
<p>Jeka follows a similar process to load options. It loads in order :</p>
<ul>
<li><em>[JEKA HOME]</em>/options.properties</li>
<li><em>[JEKA USER HOME]</em>/options.properties</li>
<li>command line parsed above</li>
</ul>
<p>The last loaded options override the previous ones if there is some conflicts.</p>
<a name="Pre-process"></a>
<h4>Pre-process <em>Def Class</em> Code (Import 3rd party library into <em>Def Classpath</em>)</h4>
<p>In order to compile <em>def classes</em>, Jeka has to compute <em>def Classpath</em> first. With Jeka you can specify run dependencies
directly inside the source code using <code>@JkDefClasspath</code> or <code>@JkImportProject</code> annotations as shown below.</p>
<pre><code class="language-Java">@JkDefClasspath(&quot;commons-httpclient:commons-httpclient:3.1&quot;)
@JkDefClasspath(&quot;com.google.guava:guava:18.0&quot;)
@JkDefClasspath(&quot;../local/library/bin&quot;)
public class HttpClientTaskRun extends JkCommandSet {

    @JkImportProject(&quot;../another/project/using/jeka&quot;)
    private OtherCommandSet otherCommandSet;  // CommandSet class from another project
    
    ...
</code></pre>
<p>To achieve this, Jeka parses source code of <em>all</em> classes under <em>jeka/def</em> and add the detected imports to the <em>def Classpath</em>.
Note that classes having a name starting by a '_' are skipped.</p>
<p>When a dependency is expressed as a maven/ivy module, Jeka tries to resolve it using repository url defined by in order :</p>
<ul>
<li>If option <code>repo.defName</code> is present and option <code>repo.${repo.defName}.url</code> is present as well, it takes the value of this property.</li>
<li>If no url is defined as such, it takes the value of <code>repo.def.url</code> option.</li>
<li>If this option is not set, then it takes the value of <code>repo.download.url</code> option.</li>
<li>If the latest is not present as well, it falls back to Maven Central.</li>
</ul>
<p>If a repository needs credentials, you need to supply it through Jeka options <code>repo.[repo name].username</code> and <code>repo.[repo name].password</code>.</p>
<p>Note that you can define several urls for a <code>repo.[repo name].url</code> by separating then with coma (as <code>repo.run.url=http://my.repo1, http://my.repo2.snapshot</code>).</p>
<p>As with other repo, if the download repository is an Ivy repo, you must prefix url with <code>ivy:</code> so for example you'll get <code>repo.run.url=ivy:file://my.ivy/repo</code>.</p>
<a name="CompileDefClasses"></a>
<h4>Compile Def Classes</h4>
<p>Jeka compiles def class source files prior to execute it. Def class source files are expected to be in <em>[PROJECT DIR]/jeka/def</em>.
Classes having a name starting by a '_' are skipped.
If this directory does not exist or does not contains java sources, the compilation is skipped.
Compilation occurs upon the following classpath :</p>
<ul>
<li>Java libraries located in <em>[PROJECT DIR]/jeka/boot</em>.</li>
<li>dev.jeka.jeka-core.jar library</li>
<li>Classpath defined in command classes as explained above.</li>
</ul>
<p>It outputs class files in <em>[PROJECT DIR]/jeka/.work/def-classes</em> directory.</p>
<p>Jeka uses the compiler provided by the running JDK.</p>
<a name="SelectCommandSetClass"></a>
<h4>Select CommandSet Class</h4>
<p>Once compiled, Jeka augments the <em>def Classpath</em> with classes compiled in previous step.
Then it selects one <em>command class</em> from <em>def classpath</em> and instantiate it.</p>
<p>The selection logic is :</p>
<ul>
<li>If <code>-CommandClass</code> option (shorthand <code>-CC</code>) is specified, then Jeka selects a class having the same name or same
short name among <em>command classes</em> present in <em>def classpath</em>.</li>
<li>If this option is not set, Jeka looks for a <em>command class</em> into <em>[PROJECT DIR]/jeka/output/def-classes</em> .
It looks in alphabetic order first then sub-package (deep first).
This means that class <code>SomeCommands</code> will be selected prior <code>apackage.SomeCommands</code>, and <code>aa.bb.SomeCommands</code> will be selected prior <code>ab.OtherCommands</code>.</li>
<li>If no such class found, Jeka selects the built-in <code>JkCommandSet</code> class.</li>
</ul>
<a name="InstantiateCommandSetClass"></a>
<h4>Instantiate CommandSet Class</h4>
<p>The commands instantiation process is defined in <code>ork.jeka.tool.JkCommandSet#of</code> factory method. It consists in :</p>
<ol>
<li>Creating a new <em>command class</em> instance (Invoking default constructor).</li>
<li>Injecting defined options in public instance fields.</li>
<li>Invoking <code>JkCommandSet#setup</code> method on <em>command class</em>. This method might be overridden by users to configure run and plugins before they have been activated.</li>
<li>Loading plugins defined in command line into the <em>command class</em> instance.</li>
<li>Invoking <code>JkPlugin#activate</code> method on each loaded plugins. This method is defined by plugin authors.</li>
<li>Invoking <code>JkCommandSet#setupAfterPluginActivations</code> on <em>command class</em>. This method might be overridden by users to configure <em>command class</em> instance once plugins have been activated.</li>
</ol>
<a name="InvokeMethodsSpecifiedinJekaCommandLinearguments"></a>
<h4>Invoke Methods Specified in Jeka Command Line arguments</h4>
<p>Once <em>commandSet class</em> instantiated, Jeka invokes instance methods mentioned in command line as <code>jeka myFistMethod mySecondMethod ...</code>.
Methods are invoked in order they appear in command line regardless if method is defined on the <em>command class</em> itself or in a plugin.</p>
<p>In order a method to be considered as a <em>command</em> (invokable from Jeka command line), it must :</p>
<ul>
<li>Be public</li>
<li>Be instance method (no static method)</li>
<li>Accept no arguments</li>
<li>Return void</li>
</ul>
<p>If Jeka command line specifies no method, then <code>help</code> method is invoked.</p>
<a name="ErrorHandling"></a>
<h4>Error Handling</h4>
<p>If an exception is thrown during the execution, Jeka displays full stack trace on the console except if
this is a <code>JkException</code>. In this case, only the message is displayed.</p>
<a name="JekafromIDE"></a>
<h3>Jeka from IDE</h3>
<a name="IDEClasspathSetting"></a>
<h4>IDE Classpath Setting</h4>
<p>In order your IDE compiles and launches your <em>def classes</em>, you must ensure that project/module classpath contains :</p>
<ul>
<li><code>dev.jeka.jeka-core.jar</code> (found in Jeka distrib)</li>
<li>libs and folders mentioned in <code>@JkDefClasspath</code> annotations of your <em>def classes</em>.</li>
<li>project/modules mentioned in <code>@JkImportProject</code> annotations of your <em>def command classes</em>.</li>
</ul>
<p>Plugin methods <code>eclipse#files</code> and <code>intellij#iml</code> achieve this for you.</p>
<a name="LaunchfromIDE"></a>
<h4>Launch from IDE</h4>
<p>If launched from the IDE, <em>def classes</em> are already compiled and the classpath already set by the IDE.
This leads in a simpler and faster process.</p>
<p>To launch Jeka from your IDE, you can go two ways :</p>
<p>One is to create a main method in one of your <em>def classes</em> as below and invoke it.</p>
<pre><code class="language-Java">public static void main(String[] args) {
    JkInit.instanceOf(MyCommands.class, args).doSomething();
} 
</code></pre>
<p>The <code>JkInit#instanceOf</code> method loads options from args and instantiates <em>command classes</em>. Then user can
configure it using hard coding prior launching any method programmatically.</p>
<p>The other way is to launch <code>Main</code> method from your IDE with same arguments as you would do with command line.</p>
<a name="Wrappermode"></a>
<h3>Wrapper mode</h3>
<p>Jeka offers a wrapper mechanism similar to let execution independent of the Jeka version installed in host machine.
This is the recommended way to use Jeka.</p>
<p>Wrapper consists in :</p>
<ul>
<li>A very small jar (about 5k) located within your project in <em>[PROJECT ROOT]/jeka/wrapper/</em>.</li>
<li>A property file <em>jeka.proparties</em> located in <em>[PROJECT ROOT]/jeka/wrapper/</em> mentionning the Jeka version yo use.</li>
<li>Two scripts <em>jekaw.bat</em> and <em>jekaw</em> installed in <em>[PROJECT ROOT]</em> to invoke in place of <em>jeka</em>.</li>
</ul>
<p>When executed in place of <em>jeka</em>, <em>jekaw</em> invoke the wrapper jar. This jar downloads the specified version of Jeka
and pass the arguments to Jeka main class.</p>
<p>To start a project with a Jeka wrapper, just execute <em>jeka scaffold#wrap</em> at the root of the project. It will add
the mentioned files above to your project. Then just invoke <em>jekaw</em> or <em>./jekaw</em> in place of <em>jeka</em>.</p>
<a name="WrapperModeinMulti-Project"></a>
<h4>Wrapper Mode in Multi-Project</h4>
<p>If you are using multi-project structure, you don't have to scaffold wrapper on each. Just scaffold Jeka at a single
place in your multi-project structure (for example in the root dir or in the 'master' project) and invoke it always
from the sub project you want to build.</p>
<p>For example execute <code>../jekaw clean java#pack</code> if the sub-project you want to build is
located in a sub-directory of the root dir.</p>
<a name="EmbeddedMode"></a>
<h3>Embedded Mode</h3>
<p>Embedded mode is the most aggressive strategy to not depend on the host machine. It consists in embedding Jeka tool itself within
the project.</p>
<p>When launched from command line, <em><strong>[JEKA_HOME]/dev.jeka.jeka-core.jar</strong></em> comes after <em><strong>[WORKING_DIR]/jeka/boot/*</strong></em> in <em>def classpath</em>.
This means that if a version of Jeka (dev.jeka.jeka-core.jar) is in this directory, the run will be processed with
this instance of Jeka instead of the one located in in <em>[JEKA HOME]</em>.</p>
<p>This is called the <strong>Embedded</strong> mode. The Jeka tool is embded within your project so the run does not depend
of the presence and version of Jeka installed in the host machine.</p>
<p>__Enable embedded mode : __</p>
<p>To enable embedded mode :</p>
<ol>
<li>Copy <em>[JEKA_HOME]/dev.jeka.jeka-core.jar</em> into <em>[PROJECT_DIR]/jeka/boot/*</em> directory.</li>
<li>Copy <em>[JEKA_HOME]/jeka.bat</em> and <em>[JEKA_HOME]/jeka</em> at the root of [PROJECT_DIR] (optional).</li>
</ol>
<p>Jeka is provided with a <em>scaffold</em> plugin that do it for you : just execute <code>jeka scaffold#run -scaffold#embed</code>.</p>
<p><strong>Run in embedded mode : </strong></p>
<p>You can go two ways :</p>
<ul>
<li>execute <code>jeka myFunction ...</code> as you would do in regular mode. This works only if you have copied jeka/jeka.bat shell scripts into <em>[PROJECT DIR]</em></li>
<li>or execute <code>java -cp jeka/boot/* Main myFunction ...</code> from <em>[PROJECT_DIR]</em> .</li>
</ul>
<a name="DefaultPathSettings"></a>
<h3>Default Path Settings</h3>
<a name="SpecifyJekaUserHome"></a>
<h4>Specify Jeka User Home</h4>
<p>Jeka uses user directory to store user-specific configuration and cache files, in this document we refer to this directory using [Jeka User Home].
By default this directory is located at <em>[User Home]/.jeka</em> (<em>[User Home]</em> being the path given by <code>System.getProperty(&quot;user.home&quot;);</code>.
You can override this setting by defining the <code>JEKA_USER_HOME</code> environment variable.</p>
<a name="SpecifytheLocalRepositoryCache"></a>
<h4>Specify the Local Repository Cache</h4>
<p>Jeka uses <a href="http://ant.apache.org/ivy/">Apache Ivy</a> under the hood to handle module dependencies. Ivy downloads and stores locally artifacts consumed by projects.
By default the location is <em>[JEKA USER HOME]/cache/repo</em> but you can redefine it by defining the <code>JEKA_REPO</code> environment variable.
You can get this location programmatically using <code>JkLocator.getJekaRepositoryCache()</code> method.</p>
<a name="SeeEffectivePaths"></a>
<h4>See Effective Paths</h4>
<p>The Jeka displays the effective path at the very start of the process if launched with <code>-LogHeaders=true</code> option :</p>
<p>For example, <code>jeka help -LogHeaders</code> will output :</p>
<pre><code>
 _______     _
(_______)   | |
     _ _____| |  _ _____
 _  | | ___ | |_/ |____ |
| |_| | ____|  _ (/ ___ |
 \___/|_____)_| \_)_____|

                           The 100% Java build tool.

Working Directory : C:\Users\me\IdeaProjects\playground\jeka-sample
Java Home : C:\Program Files (x86)\Java\jdk1.8.0_121\jre
Java Version : 1.8.0_121, Oracle Corporation
Jeka Version : Xxxxx
Jeka Home : C:\Users\me\IdeaProjects\jeka\dev.jeka.core\jeka\output\distrib
Jeka User Home : C:\Users\me\.jeka
Jeka Repository Cache : C:\Users\me\.jeka\cache\repo

...
</code></pre>
<a name="CommandSetParameters"></a>
<h2>CommandSet Parameters</h2>
<p>Jeka commands are parameterizable. One can retrieve values defined at runtime by reading :</p>
<ul>
<li>environment variables</li>
<li>system properties</li>
<li>Jeka options</li>
</ul>
<a name="EnvironmentVariables"></a>
<h3>Environment Variables</h3>
<p>You can fetch environment variables using the standard <code>System#getenv</code> method or by annotating a public instance field
with <code>@JkEnv</code>. <em>JkOption</em> mechanism takes precedence on environment variable injection.</p>
<a name="SystemProperties"></a>
<h3>System Properties</h3>
<p>As for environment variables, one can read system properties using the standard <code>System#getProperty</code> method.</p>
<p>Jeka proposes 3 ways of injecting system properties. They are considered in following order :</p>
<ul>
<li>Properties mentioned in Jeka command line as <code>Jeka doDefault -DmyProperty=myValue</code>.</li>
<li>Properties mentioned in <em>[Jeka User Home]/system.properties</em> file.</li>
<li>Properties mentioned in <em>[Jeka Home]/system.properties</em> file.
Note that if you are running Jeka in embedded mode, the <em>[Jeka Home]/system.properties</em> file will not be taken in account but <em>[project dir]/jeka/boot/system.properties</em>.</li>
</ul>
<p>In every case, defined system properties are injected after the creation of the java process (via <code>System#setProperty</code> method).</p>
<a name="JekaOptions"></a>
<h3>Jeka Options</h3>
<p>Jeka options are similar to system properties as it stands for a set of key/value.</p>
<p>Options are globally available in all command classes but can be retrieve in a static typed way (injected in <em>command class</em> fields)
or as set of key/string value.</p>
<a name="InjectOptions"></a>
<h4>Inject Options</h4>
<p>Jeka proposes 3 ways to inject options. They are considered in following order :</p>
<ul>
<li>Options mentioned in Jeka command line as <code>Jeka doDefault -myOption=myValue</code>.</li>
<li>Options mentioned in <em>[Jeka User Home]/options.properties</em> file.</li>
<li>Options mentioned in <em>[Jeka Home]/options.properties</em> file.
Note that if you are running Jeka in embedded mode, the <em>[Jeka Home]/options.properties</em> file will not be taken in account but <em>[project dir]/jeka/boot/options.properties</em>.</li>
</ul>
<p>Note for boolean options, when no value is specified, <code>true</code> will be used as default.</p>
<a name="RetrieveOptionsasStringValues"></a>
<h4>Retrieve Options as String Values</h4>
<p>You can retrieve string values using the <code>JkOptions</code> API providing convenient static methods as <code>JkOptions#get</code>, <code>JkOptions#getAll</code> or <code>JkOptions#getAllStartingWith(String prefix)</code>.</p>
<p>This way you only get the string literal value for the option and you have to parse it if the intended type was a boolean or a number.</p>
<a name="RetrieveOptionsinCommandSetClassFields"></a>
<h4>Retrieve Options in CommandSet Class Fields</h4>
<p>You can retrieve options just by declaring fields in <em>command classes</em>.
All public non-final instance fields of the invoked <em>command class</em>, are likely to be injected as an option. Note that
it can be private, but a public setter must be present.</p>
<p>For example, if you declare a field like :</p>
<pre><code>class MyRun extends JkCommandSet {
   public int size = 10;
   ...
}
</code></pre>
<p>Then you can override the value by mentioning in command line <code>jeka doSomething -size=5</code>.</p>
<p>Note that the injected string value will be automatically converted to the target type.</p>
<p>Handled types are : <em>String</em>, <em>all primitive types (and their wrappers)</em>, <em>enum</em>, <em>File</em> and <em>composite object</em>.
If the value is not parsable to the target type, commands fails.</p>
<p>To get a precise idea on how types are converted see <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/org/jeka/tool/OptionInjector.java">this code</a>.</p>
<a name="Compositeoptions"></a>
<h4>Composite options</h4>
<p>Composite options are a way to structure your options. Say that you want to configure some server access with url, userName and passwsord.
You can group all these information into a single object as :</p>
<pre><code class="language-Java">public class Server {
    public String url;
    public String userName;
    public String password;
    // ...
}
</code></pre>
<p>Declare a new field of type <code>Server</code> in your command class :</p>
<pre><code class="language-Java">class MyRun extends JkCommandSet {
   public Server deployServer = new Server();
   ...
}
</code></pre>
<p>Then you can inject the server object using following options :</p>
<pre><code>deployServer.url=http:/myServer:8090/to
deployServer.username=myUsername
deployServer.password=myPassword
</code></pre>
<a name="DocumentOptions"></a>
<h4>Document Options</h4>
<p>If you want your option been displayed when invoking <code>jeka help</code> you need to annotate it with <code>@JkDoc</code>.</p>
<p>For example :</p>
<pre><code>@JkDoc(&quot;Make the test run in a forked process&quot;)
public boolean forkTests = false;
</code></pre>
<a name="Built-inOptions"></a>
<h4>Built-in Options</h4>
<p>Jeka defines some built-in options that are used by the engine itself. Unlike regular options, they respect an UpperCamelCase naming
convention :</p>
<ul>
<li>-LogVerbose (shorthand -LV) : if true, logs will display 'trace' level logs.</li>
<li>-LogHeaders (shorthand -LH) : if true, meta-information about the run creation itself and method execution will be logged.</li>
<li>-LogMaxLength (shorthand -LML) : Console will do a carriage return automatically after N characters are outputted in a single line (ex : -LML=120).</li>
<li>-CommandClass (shorthand -CC) : Force to use the specified class as the <em>command class</em> to instantiate. It can be the short name of the class (without package prefix).</li>
</ul>
<a name="Plugins"></a>
<h2>Plugins</h2>
<p>Jeka provides a pluggble architecture. In Jeka, a plugin is a class extending <code>JkPlugin</code> and named as <em>JkPlugin[PluginName]</em>.
The plugin name is inferred from Plugin class name.</p>
<p>Each plugin instance is owned by a JkCommandSet object, and can access to it through <code>JkPlugin#owner</code> protected field.</p>
<p>Plugins has 3 capabilities :</p>
<ul>
<li>Access to their owning JkCommandSet instance (so potentially modify it, load/modify other plugins).</li>
<li>Expose <em>commands</em> and <em>options</em> to command line.</li>
<li>Provide self documentation.</li>
</ul>
<p>Jeka is bundled with a bunch of plugins (java, scaffold, eclipse, intellij, ...) but one can add extra plugins just
by adding a jar or directory containing the plugin class to the <em>def classpath</em>.</p>
<p>To see all available plugins in the <em>def classpath</em>, just execute <code>jeka help</code>.
See <a href="#CommandLineParsing">Command Line Parsing</a> and <a href="#RunClassPre-processing(Import3rdpartylibraryintoRunClasspath)">Run Class Pre-processing</a>
to augment <em>def classpath</em> .</p>
<a name="LoadPlugins"></a>
<h3>Load Plugins</h3>
<p>Plugins need not to be mentioned in <em>commandSet class</em> code in order to be bound to the JkCommandSet instance. Just the fact to
mention a plugin in the command line loads it.</p>
<p>For example <code>jeka scaffold#run java#</code> will load 'java' and 'scaffold' plugins into a JkCommandSet instance.
'java' plugin instance will modify 'scaffold' plugin instance in such it produces a commandSet class declaring 'java' plugin
when 'scaffold#run' is executed. It also creates Java project layout folders. See <code>activate</code> method in <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/dev/jeka/tool/builtins/java/JkPluginJava.java">JkPluginJava Code</a>
to have a concrete view.</p>
<p>You can also force a plugin to be loaded in your <em>commandSet class</em> code as below. That way, you don't need to mention <code>java#</code> in command line.</p>
<pre><code class="language-Java">public class MyBuild extends JkCommandSet {
    
    MyBuild() {
        getPlugin(JkPluginJava.class);  // Loads 'java' plugins in MyBuild instances, a second call on 'plugins().get(JkPluginJava.class)' would return the same JkPluginJava instance.
        getPlugin(&quot;intellij&quot;);   // You can also load plugins by mentioning their name but it's slower cause it involves classpath scanning
    }
    
}
</code></pre>
<a name="ModifyJkCommandSetInstance"></a>
<h3>Modify JkCommandSet Instance</h3>
<p>JkCommandSet instances are created using <code>JkCommandSet#of</code> factory method.
This method invokes <code>JkPlugin#activate</code> method on all plugins loaded in the JkCommandSet instance.
By default, <code>activate</code> method does nothing but plugin implementations can override it in order to let the plugin modify its JkCommandSet instance or one of its plugins.
In fact, many plugins act just as modifier/enhancer of other plugins.</p>
<p>For example, <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/org/jeka/tool/builtins/jacoco/JkPluginJacoco.java">Jacoco Plugin</a>
does not provide <em>commands</em> but configures 'java' plugin in such unit tests are forked on a JVM with Jacoco agent on.
It also provides a utility class <code>JKocoJunitEnhancer</code> that supplies lower level features to launch Jacoco programmatically.</p>
<p>Some other plugins does not modify their owning JkCommandSet instance, for example <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/org/jeka/tool/builtins/scaffold/JkPluginScaffold.java">Scaffold Plugin</a>
does not override <code>activate</code> method, therefore it has no side effect on its owning <code>JkCommandSet</code> instance. It only features extra <em>commands</em> and <em>options</em>.</p>
<a name="ConfigurePluginsinJkCommandSetClass"></a>
<h3>Configure Plugins in JkCommandSet Class</h3>
<p>There is three places where you can configure plugins :</p>
<ul>
<li>In <code>JkCommandSet</code> subclass constructors : at this point options has not yet been injected so it's the place to configure default option values.</li>
<li>In <code>JkCommandSet#setup</code> subclass method : at this point, options has been injected but plugins has not been activated yet.
It is the place to configure plugins and other instance member to take options in account before activation.</li>
<li>In <code>JkCommandSet#setupAfterPluginActivations</code> subclass method : at this point plugins has been activated. If you wan't to override
some values plugin activation may have set, override this method.</li>
</ul>
<p>Example of configuring a plugin in <em>commandSet class</em>.</p>
<pre><code class="language-Java">
    JkPluginSonar sonarPlugin = getPlugin(JkPluginSonar.class);  // Load sonar plugin 
    
    ...
    public MyBuild() {
		sonarPlugin.prop(JkSonar.BRANCH, &quot;myBranch&quot;);  // define a default for sonar.branch property
        ...
    }
</code></pre>
<p><a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/jeka/def/org/jeka/CoreBuild.java">Jeka own build class</a> makes a good example.</p>
<a name="DocumentPlugins"></a>
<h3>Document Plugins</h3>
<p>Plugin authors can embed self-documentation using <code>@JkDoc</code> annotation on classes, command methods and option fields.</p>
<p>Writers can also mention that the plugin has dependencies on other plugins using <code>@JkDocPluginDeps</code> annotation. This annotation
has only a documentation purpose and does not has influence on plugin loading mechanism.</p>
<p>A good example is <a href="https://github.com/jeka/jeka/blob/master/dev.jeka.core/src/main/java/org/jeka/tool/builtins/java/JkPluginJava.java"><em>Java Plugin</em></a></p>
<a name="ImportExternalRuns"></a>
<h2>Import External Runs</h2>
<p>There is many way to perform multi-project build. One of is to import runs from external projects.</p>
<a name="Principle"></a>
<h3>Principle</h3>
<p>A <em>commandSet class</em> instance can import <em>commandSet class</em> instances from other projects.</p>
<p>The current <em>def classpath</em> is augmented with the <em>def classpath</em> of imported projects.</p>
<p>Imported runs are not aware they are imported. In fact any run can be imported. The relation is uni-directional.</p>
<a name="DeclareRunImport"></a>
<h3>Declare Run Import</h3>
<p>To import a <em>commandSet class</em> from an external project, use the <code>@JkImportProject</code> annotation as shown below :</p>
<pre><code class="language-Java">public class MyCommands extends JkCommandSet {
    
    @JkImportProject(&quot;../otherProject&quot;)   
    private BarCommands importedCommands;  

    public void doSomesthing() {
       importedCommands.doBar();   // use the command class defined in ../otherProject
       ...
</code></pre>
<p><em>CommandSet classes</em> are imported transitively, this means that, in above example, if <code>BarCommands</code> imports an other project, this
last will be also imported.</p>
<a name="OptionPropagation"></a>
<h3>Option Propagation</h3>
<p>Options mentioned in command line are propagated to the imported commandSets.</p>
<p>So for example you execute <code>jeka java#pack -java#tests.fork</code>, test will be forked for the main run and all imported ones.</p>
<a name="Methodpropagation"></a>
<h3>Method propagation</h3>
<p>Methods mentioned in the command line are not automatically propagated to imported runs. Executing <code>jeka clean</code> will
only clean the current run project.</p>
<p>To propagate method call to every imported commandSets, method name should be prefixed with a '*'. Executing <code>jeka clean*</code> will
invoke 'clean' method on the current <em>commandSet class</em> along along all imported commandSet classes.</p>
<a name="AccessImportedRunsProgrammatically"></a>
<h3>Access Imported Runs Programmatically</h3>
<p>You can access to the list of imported commandSet classes within using <code>JkCommandSet#getImportedCommandSets</code> methods as show below :</p>
<pre><code class="language-Java">public class MyRun extends JkCommandSet {

    ...

    public void doForAll() {
        this.clean();
        this.getImportedCommandSets().getAll().forEach(JkRun::clean);
        this.getImportedCommandSets().getAllOf(JkJavaProjectBuild.class).forEach(build -&gt; build.java().pack());
    }
</code></pre>
<a name="SelfDocumentation"></a>
<h2>Self Documentation</h2>
<p><em>CommandSet classes</em> and plugins can provide self documentation.</p>
<p>When properly auto-documented, users can display documentation by executing <code>jeka help</code>.</p>
<p>The displayed documentation consist in :</p>
<ul>
<li>The Jeka Built-in option</li>
<li>A general description of the commandSet class (its purpose). This information is provided by using <code>@JkDoc</code> annotation at class level.</li>
<li>A description of each <em>command</em>. The description is provided by using <code>@JkDoc</code>.</li>
<li>A description of accept options, with its type and default value. The description is provided by using <code>@JkDoc</code> annotation on public fields.</li>
<li>The plugins available in the classpath.</li>
</ul>
<p>If <em>commandSet class</em> or plugin declares a public instance field without <code>@JkDoc</code> annotation, then it will be displayed in help screen but mentioning that there is no description available.</p>
<p>If <em>commandSet class</em> or plugin declares a <em>command</em> without <code>@JkDoc</code>, it will be also displayed in help screen but mentioning that there is no description available.</p>
<p>This is the display screen for the Jeka project commandSet class :</p>
<pre><code>Usage: jeka [methodA...] [pluginName#methodB...] [-optionName=value...] [-pluginName#optionName=value...] [-DsystemPropName=value...]
Execute the specified methods defined in commandSet class or plugins using the specified options and system properties.
When no method specified, 'doDefault' method is invoked.
Ex: jeka clean java#pack -java#pack.sources=true -LogVerbose -other=xxx -DmyProp=Xxxx

Built-in options (these options are not specific to a plugin or a build class) :
  -LogVerbose (shorthand -LV) : if true, logs will display 'trace' level logs.
  -LogHeaders (shorthand -LH) : if true, meta-information about the build creation itself and method execution will be logged.
  -LogMaxLength (shorthand -LML) : Console will do a carriage return automatically after N characters are outputted in a single line (ex : -LML=120).
  -CommandClass (shorthand -CC) : Force to use the specified class as the commandSet class to be invoked. It can be the short name of the class (without package prefix).

Available methods and options :

From class CoreBuild :
  Methods :
    doDefault : Conventional method standing for the default operations to perform.
  Options :
    -testSamples (boolean, default : false) : If true, executes black-box tests on sample projects prior ending the distrib.

From class JkCommandSet :
  Methods :
    clean : Cleans the output directory.
    help : Displays all available methods defined in this build.

Available plugins in classpath : eclipse, eclipsePath, intellij, jacoco, java, pgp, pom, repo, scaffold, sonar.

Type 'jeka [pluginName]#help' to get help on a perticular plugin (ex : 'jeka java#help').
Type 'jeka help -Plugins' to get help on all available plugins in the classpath.

</code></pre>
</body>
</html>