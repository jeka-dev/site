<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style/style.css" />
    <link rel="stylesheet" href="style/menuItem.css" />

    <!-- highlight.js -->
    <script src="style/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link rel="stylesheet" href="style/highlight-idea.css">

    <title>Jeka - Getting Started</title>
</head>

<body>
<div class="title">Jeka - Getting Started</div>
<br/>
<div style="color: lightslategrey; font-size: large">Author : Jérôme Angibaud</div>
<div style="color: lightslategrey; font-size: large">Version : master-SNAPSHOT</div>
<br />
<a href="#InstallJeka" class="menuItem1">Install Jeka</a><br />
<a href="#ConfigureyourIDE" class="menuItem1">Configure your IDE</a><br />
<a href="#Intellij" class="menuItem2">Intellij</a><br />
<a href="#Eclipse" class="menuItem2">Eclipse</a><br />
<a href="#Note" class="menuItem2">Note</a><br />
<a href="#Jekaconcepts" class="menuItem1">Jeka concepts</a><br />
<a href="#Basicautomationproject" class="menuItem1">Basic automation project</a><br />
<a href="#Createaproject" class="menuItem2">Create a project</a><br />
<a href="#Addacommand" class="menuItem2">Add a command</a><br />
<a href="#Selfdocumentyourmethod" class="menuItem2">Self document your method</a><br />
<a href="#Addanoption(parameter)" class="menuItem2">Add an option (parameter)</a><br />
<a href="#Use3rdpartylibsinyourJekaclass" class="menuItem2">Use 3rd party libs in your Jeka class</a><br />
<a href="#ImportaJekaclassfromanotherJekaproject" class="menuItem2">Import a Jeka class from another Jeka project</a><br />
<a href="#Restrictions" class="menuItem2">Restrictions</a><br />
<a href="#Workwithplugins" class="menuItem1">Work with plugins</a><br />
<a href="#Writeyourfirstplugin" class="menuItem2">Write your first plugin</a><br />
<a href="#Whatdidhappenedbehindthescene?" class="menuItem2">What did happened behind the scene ?</a><br />
<a href="#ConfigurepluginswithintheJekaclass" class="menuItem2">Configure plugins within the Jeka class</a><br />
<a href="#Configure/Enhanceapluginfromanotherone" class="menuItem2">Configure/Enhance a plugin from another one</a><br />
<a href="#Reuseapluginacrossprojects" class="menuItem2">Reuse a plugin across projects</a><br />
<a href="#Develop" class="menuItem3">Develop</a><br />
<a href="#Pack" class="menuItem2">Pack</a><br />
<a href="#Reuse" class="menuItem2">Reuse</a><br />
<a href="#BuildaJavaproject" class="menuItem1">Build a Java project</a><br />
<a href="#BuildJavaprojectusinglow-levelAPI" class="menuItem2">Build Java project using low-level API</a><br />
<a href="#BuildJavaprojectusinghighlevelAPI" class="menuItem2">Build Java project using high level API</a><br />
<a href="#BuildJavaprojectusingJekaJavaplugin." class="menuItem2">Build Java project using Jeka Java plugin.</a><br />
<a href="#Buildyourproject" class="menuItem2">Build your project</a><br />
<a href="#Extrafunction" class="menuItem2">Extra function</a><br />
<a href="#Explorefunctionsandoptionsprovidedout-of-thebox" class="menuItem2">Explore functions and options provided out-of-thebox</a><a name="InstallJeka"></a>
<h1>Install Jeka</h1>
<p>Jeka deals with 3 directories :</p>
<p><strong>[PROJECT DIR]</strong> : Refers to the root folder of the project to build (or to run commands on). This is where you would put pom.xml or build.xml files.</p>
<p><strong>[JEKA HOME]</strong> : Refers to the folder where Jeka is installed. You should find <em>jeka.bat</em> and <em>jeka</em> shell scripts at the root of this folder.</p>
<p><strong>[JEKA USER HOME]</strong> : Refers to the folder where Jeka stores caches, binary repository and global user configuration. By default it is located at [USER DIR]/.jeka.</p>
<p>Thank to the wrapper feature, normally you don't need to install Jeka on your machine to run it... except if you are
creating projects from scratch.
As it's what we are going to do in this tutorial, you have to get it properly installed.</p>
<ol>
<li>Download and unzip the lastest <em>core-x.x.x-distrib.zip</em> file found on <a href="https://oss.sonatype.org/content/repositories/snapshots/dev/jeka/jeka-core/">snapshot</a> or <a href="https://search.maven.org/search?q=g:%22dev.jeka%22%20AND%20a:%22jeka-core%22">release</a> repository to the directory you want to install Jeka.</li>
<li>Add <em>JEKA HOME</em> (repositoty where you have unzipped the distribution) to your PATH environment.</li>
<li>Make sure that either a valid JDK is on your <em>PATH</em> environment variable or that a <em>JAVA_HOME</em> variable is pointing on (<em>JAVA_HOME</em>/bin/java must point on a java executable).
Note that you can choose a specific JDK instance to run Jeka without affecting <em>JAVA_HOME</em> variable by setting <em>JEKA_JDK</em> environment variable (<em>JEKA_JDK</em>/bin/java must point on a java executable).
Required Jdk version for running Jeka is 8 or more (tested until 12). Jdk 7 is no more supported.</li>
<li>execute <code>jeka help</code> in the command line. You should get an output starting by :</li>
</ol>
<pre><code>Usage:

jeka (method | pluginName#method) [-optionName=&lt;value&gt;] [-pluginName#optionName=&lt;value&gt;] [-DsystemPropertyName=value]

Executes the specified methods defined in commandSet class or plugins using the specified options and system properties.

Ex: jeka clean java#pack -java#pack.sources=true -LogVerbose -other=xxx -DmyProp=Xxxx
...
</code></pre>
<div class="alert alert-primary" role="alert">
You can display Jeka metadata information by adding `-LH` (or `-LogHeaders`) to the command line. You should get the following output.
</div>
<pre><code> _______     _
(_______)   | |
     _ _____| |  _ _____
 _  | | ___ | |_/ |____ |
| |_| | ____|  _ (/ ___ |
 \___/|_____)_| \_)_____|

                           The pure Java build tool.


Working Directory : C:\Users\djeang\IdeaProjects\jeka
Java Home : C:\Program Files (x86)\Java\jdk1.8.0_121\jre
Java Version : 1.8.0_121, Oracle Corporation
Jeka Version : null
Jeka Home : C:\Users\djeang\IdeaProjects\jeka\dev.jeka.core\jeka\output\distrib
Jeka User Home : C:\Users\djeang\.jeka
Jeka Run Repositories : [https://repo.maven.apache.org/maven2/, file:/C:/Users/djeang/.jeka/maven-publish-dir/]
Jeka Repository Cache : C:\Users\djeang\.jeka\cache\repo
Jeka Classpath : C:\Users\djeang\IdeaProjects\jeka\dev.jeka.core\jeka\output\distrib\dev.jeka.jeka-core.jar
Command Line : -LH help
Specified System Properties : none.
Standard Options : RunClass=null, LogVerbose=false, LogHeaders=true, LogMaxLength=230
Options :   LH=null  LML=230  jdk.9=C:/Program Files (x86)/Java/jdk9.0.1 jdk.10=C:/Program Files (x86)/Java/jdk10.0.2  repo.download.url=https://repo.maven.apache.org/maven2/
Compile and initialise commandSet classes ...
│ Initializing class JkClass at C:\Users\djeang\IdeaProjects\jeka ...
│ │ Run instance initialized with options []
│ └ Done in 57 milliseconds.
└ Done in 336 milliseconds.
Jeka commands are ready to be executed.
Method : help on JkClass
Usage:
jeka (method | pluginName#method) [-optionName=&lt;value&gt;] [-pluginName#optionName=&lt;value&gt;] [-DsystemPropName=value]

Execute the specified methods defined in commandSet class or plugins using the specified options and system properties.
Ex: jeka clean java#pack -java#pack.sources=true -LogVerbose -other=xxx -DmyProp=Xxxx
...

Method help succeeded in 660 milliseconds.
  ______                                     _
 / _____)                                   | |
( (____  _   _  ____ ____ _____  ___  ___   | |
 \____ \| | | |/ ___) ___) ___ |/___)/___)  |_|
 _____) ) |_| ( (__( (___| ____|___ |___ |   _
(______/|____/ \____)____)_____|___/(___/   |_|

                                               Total run duration : 1.159 seconds.

</code></pre>
<a name="ConfigureyourIDE"></a>
<h1>Configure your IDE</h1>
<p>While a visual Jeka plugin for Intellij exists (a plugin to be installed on Intellij), we will ignore it in this tutorial.
You can still work pretty well thanks to Intellij and Eclipse Jeka plugin whose generating IDE metadata files (.iml and .classpath).</p>
<p>But first you have to instruct your IDE where is located Jeka distribution and repositories.</p>
<a name="Intellij"></a>
<h2>Intellij</h2>
<p>Declare the 2 path variables (go settings -&gt; Apparence &amp; behavior -&gt; Path Variables)</p>
<ul>
<li><code>JEKA_HOME</code> which point to <em>[Jeka Home]</em>,</li>
<li><code>JEKA_USER_HOME</code> which point to <em>[Jeka User Home]</em></li>
</ul>
<a name="Eclipse"></a>
<h2>Eclipse</h2>
<p>Declare the 2 classpath variables in Eclipse.</p>
<ol>
<li>Open the Eclipse preference window : <em>Window -&gt; Preferences</em></li>
<li>Navigate to the classpath variable panel : <em>Java -&gt; Build Path -&gt; Classpath Variables</em></li>
<li>Add these 2 variables :
<ul>
<li><code>JEKA_HOME</code> which point to <em>[Jeka Home]</em>,</li>
<li><code>JEKA_USER_HOME</code> which point to <em>[Jeka User Home]</em>.</li>
</ul>
</li>
</ol>
<a name="Note"></a>
<h2>Note</h2>
<p>By default <em>[Jeka User Home]</em> point to <em>[User Home]/.jeka</em> but can be overridden by defining the environment
variable <code>JEKA_USER_HOME</code>.</p>
<a name="Jekaconcepts"></a>
<h1>Jeka concepts</h1>
<p><strong>Def Classes :</strong> Java source files located under <em>[PROJECT DIR]/jeka/def</em>. They are compiled on the flight by Jeka when invoked from the command line.</p>
<p><strong>Def Classpath :</strong> Classpath on which depend <em>def classes</em> to get compiled and run.
By default, it consists in <em>Jeka</em> core classes but it can be augmented with any third party lib or <em>def classpath</em> coming
from other Jeka projects.</p>
<p><strong>Jeka Classes :</strong> Classes extending <code>JkClass</code>. Their public no-arg methods can be invoked from the command line
if they belong to <em>def classpath</em>. Their public properties can be set from the command line as well.
Also, <em>plugins</em> are bound to <em>Jeka Class</em>. Typically, <em>def classes</em>  include one <em>Jeka class</em>.</p>
<p><strong>Jeka Method :</strong> Java method member of <em>cJeka class</em> invokable from command line.
They must be instance method (not static), public, zero-args and returning void.
Every method verifying these constraints within a <em>JkClass class</em> or a <em>plugin</em>  is considered as a <em>command</em>.</p>
<p><strong>Options :</strong> This is a set of key-value used to inject parameters. Options can be mentioned
as command line arguments, stored in specific files or hard coded in <em>Jeka classes</em>. Options can be injected
in <em>Jeka class</em> or <em>plugin</em> instance fields.</p>
<p><strong>Plugins :</strong> Classes extending <code>JkPlugin</code> and named as <em>JkPluginXxxxx</em> where_Xxxxx_ is the name of the plugin. In short, a plugin
add dynamically commands and options to the running <em>Jeka class</em>.</p>
<a name="Basicautomationproject"></a>
<h1>Basic automation project</h1>
<p>First, let's create a simple automation project that read content from url and display it on the console.</p>
<a name="Createaproject"></a>
<h2>Create a project</h2>
<ol>
<li>Create the root directory of your project (here 'sample1').</li>
<li>Open a terminal/console and cd to <em>sample1</em> directory. Jeka should be always executed from the root of the project.</li>
<li>Execute <code>jeka scaffold#run intellij#</code> under this directory (replace <code>intellij#</code> by <code>eclipse#</code> if you're using Eclipse).<br />
This will generate a project skeleton as follow :</li>
</ol>
<pre><code>sample1
   + jeka             
      + def             &lt;-----  Java code that build your project goes here
         + Build.java   
      + output          &lt;---- Genererated files are supposed to lie here  
   + sample1.iml    &lt;----- Intellij metadata containing project dependencies (At least dev.jeka.core)
</code></pre>
<ol start="4">
<li>Import the project in your IDE. Everything should be Ok, in particular <em>Build.java</em> should compile and execute within your IDE.</li>
</ol>
<pre><code class="language-java">import dev.jeka.core.tool.JkClass;
import dev.jeka.core.tool.JkInit;

class Commands extends JkClass {

    public static void main(String[] args) {
        Commands commands = JkInit.instanceOf(Commands.class, args);
        commands.clean();
    }

}
</code></pre>
<a name="Addacommand"></a>
<h2>Add a command</h2>
<p>Add the following method to the <code>Commands</code> class.</p>
<pre><code class="language-java">import dev.jeka.core.api.utils.JkUtilsIO;
import dev.jeka.core.tool.JkClass;
import dev.jeka.core.tool.JkInit;

import java.net.MalformedURLException;
import java.net.URL;

class Commands extends JkClass {

    public void displayGoogle() throws MalformedURLException {
        String content = JkUtilsIO.read(new URL(&quot;https://www.google.com/&quot;));
        System.out.println(content);
    }

    public static void main(String[] args) throws Exception {
        JkInit.instanceOf(Commands.class, args).displayGoogle();
    }

}

</code></pre>
<p>Open a  console/:terminal in <em>sample1</em> directory and execute <code>jeka displayGoogle</code>. You should see the Google source displayed.</p>
<p>Execute <code>jeka help</code> and the output should mention your new method.</p>
<pre><code>...
From class Commands :
  Methods :
    displayGoogle : No description available.

From class JkClass :
  Methods :
    clean : Cleans the output directory.
    help : Displays all available methods and options defined for this Jeka class.
...
</code></pre>
<p>Any public instance method with no-args and returning <code>void</code> fits to be a <em>command</em>. You can call several <em>commands</em> in a single row.</p>
<p>You can also launch/debug command directly from your IDE, using the <em>main</em> method. Note that for so, you must instantiate
your <em>Jeka class</em> using <code>JkInit.instanceOf</code>.</p>
<a name="Selfdocumentyourmethod"></a>
<h2>Self document your method</h2>
<p>Add the following annotation to the <em>command</em>.</p>
<pre><code class="language-java">@JkDoc(&quot;Fetch Google page and display its source on the console.&quot;)
public void displayGoogle() throws MalformedURLException {
    String content = JkUtilsIO.read(new URL(&quot;https://www.google.com/&quot;));
    System.out.println(content);
}
</code></pre>
<p>Execute <code>jeka help</code> and the output should mention documentation.</p>
<pre><code>From class Build :
  Methods :
    displayGoogle : Fetch Google page and display its source on the console.
</code></pre>
<a name="Addanoption(parameter)"></a>
<h2>Add an option (parameter)</h2>
<p>May you like to see Google page source but you probably want to apply this method to any other url.</p>
<p>To make it configurable, just declare the url in a public field so its value can be injected from command line.</p>
<pre><code class="language-java">class Commands extends JkClass {

    @JkDoc(&quot;The url to display content.&quot;)   // Optional self documentation
    public String url = &quot;https://www.google.com/&quot;;

    @JkDoc(&quot;Fetch Google page and display its source on the console.&quot;)
    public void displayContent() throws MalformedURLException {
        String content = JkUtilsIO.read(new URL(url));
        System.out.println(content);
    }

    public static void main(String[] args) throws Exception {
        JkInit.instanceOf(Commands.class, args).displayContent();
    }

}
</code></pre>
<p>Execute <code>jeka displayContent -url=https://github.com/github</code> and you should see the Github page source displayed.</p>
<p>If you execute <code>jeka help</code> you should see the url option mentioned.</p>
<pre><code>...
From class Commands :
  Methods :
    displayContent : Fetch Google page and display its source on the console.
  Options :
    -url (String, default : https://www.google.com/) : The url to display content.
...
</code></pre>
<a name="Use3rdpartylibsinyourJekaclass"></a>
<h2>Use 3rd party libs in your Jeka class</h2>
<p>You can mention inline the external libraries you need to compile and execute your <em>command class</em>. For exemple, you main need <em>Apache HttpClient</em> library to perform some non basic HTTP tasks.</p>
<ol>
<li>Annotate your class with modules or jar files you want to use.</li>
</ol>
<pre><code class="language-java">@JkDefClasspath(&quot;org.apache.httpcomponents:httpclient:jar:4.5.8&quot;)  // Can import files from Maven repos
@JkDefClasspath(&quot;../local_libs/my-utility.jar&quot;)   // or simply located locally
class Commands extends JkClass {
   ...
}
</code></pre>
<ol start="2">
<li>
<p>Execute <code>jeka intellij#iml</code> or <code>jeka eclipse#files</code> to add properly the dependencies to your IDE (You may need to refresh it).</p>
</li>
<li>
<p>You can add code depending on the imported libs</p>
</li>
</ol>
<pre><code class="language-java">import org.apache.http.client.methods.HttpPost;
...
public void post() {
    HttpPost httpPost = new HttpPost();
    httpPost.setHeader(&quot;content-type&quot;, &quot;application/json&quot;);
    ...
}
</code></pre>
<p>Execute <em>post</em> method as usual : <code>jeka post</code>.</p>
<a name="ImportaJekaclassfromanotherJekaproject"></a>
<h2>Import a Jeka class from another Jeka project</h2>
<p>Imagine that you want to want to reuse <em>displayContent</em> method from project <em>sample1</em> in another project. Let's create a new <em>sample2</em> project located in a sibling folder than <em>sample1</em>.</p>
<ol>
<li>Execute <code>mkdir sample2</code> then <code>cd sample2</code> followed by <code>jeka scaffold#run intellij#</code> (or <code>jeka scaffold#run eclipse#</code>)</li>
<li>Rename sample2 <em>Jeka class</em> 'Sample2Commands` to avoid name collision. Be careful to rename its filename as well unless Jeka will fail.</li>
<li>Add a field of type <code>JkClass</code> annotated with <code>JkImportProject</code> and the relative path of <em>sample1</em> as value.</li>
</ol>
<pre><code class="language-java">class Sample2Commands extends JkClass {

    @JkDefClasspathProject(&quot;../sample1&quot;)
    private JkClass sample1Commands;

    public void hello() throws MalformedURLException {
        System.out.println(&quot;Hello World&quot;);
    }
    
}
</code></pre>
<ol start="4">
<li>
<p>Execute <code>jeka intellij#iml</code> (or <code>jeka eclipse#files</code>) to add <em>sample1</em> dependencies to your IDE. Now <em>Sampl2Commands</em> can refer to the <em>Jeka class</em> of <em>sample1</em>.</p>
</li>
<li>
<p>Replace <em>JkClass</em> Type by the <em>Commands</em> type from <em>sample1</em> and use it in method implementation.</p>
</li>
</ol>
<pre><code class="language-java">class Sample2Commands extends JkClass {

    @JkDefClasspathProject(&quot;../sample1&quot;)
    private Commands sample1Commands;  // This class comes from sample1

    public void printUrlContent() throws MalformedURLException {
        System.out.println(&quot;Content of &quot; + sample1Commands.url);
        sample1Commands.displayContent();
    }

}
</code></pre>
<p>Executing <code>jeka printUrlContent</code> displays :</p>
<pre><code>Content of https://www.google.com/
&lt;!doctype html&gt;&lt;html itemscope=&quot;&quot; itemtype=&quot;http://schema.org/WebPage&quot; lang=&quot;nl-BE&quot;&gt;&lt;head&gt;&lt;meta content=&quot;text/html; charset=UTF-8&quot; http-equiv=&quot;Content-Type&quot;&gt;&lt;meta content=&quot;/images/branding/googleg/1x/googleg_standard_color_128dp.pn
    g&quot; itemprop=&quot;image&quot;&gt;&lt;title&gt;Google&lt;/title&gt;&lt;script nonce=&quot;JkJFrHNh1i7pdGGBGDk/tw==&quot;&gt;(function(){window.google={kEI:'AyndXKnDGrLgkgW-kp7gAw',kEXPI:'0,1353747,57,1958,1640,782,698,527,731,223,1575,1257,1894,58,320,207,1017,167,438,
...
</code></pre>
<p>You can set directly the value of the url on the command line as option values are injected on all imported commands recursively.</p>
<p><code>jeka printUrlContent -url=https://github.com/github</code> displays :</p>
<pre><code>Content of https://fr.wikipedia.org
&lt;!DOCTYPE html&gt;
&lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;/&gt;
&lt;title&gt;Wikipedia, the free encyclopedia&lt;/title&gt;
...
</code></pre>
<a name="Restrictions"></a>
<h2>Restrictions</h2>
<p>Except that <em>Jeka classes</em> must have the same name than their filename, there is not known restriction about what you can do with <em>Jeka classes</em> or <em>def classes</em>.
You can define as many classes as you want into def directory. Organise them within Java packages or not.</p>
<a name="Workwithplugins"></a>
<h1>Work with plugins</h1>
<p>Each <em>Jeka class</em> instance acts as a registry for plugins. In turn, plugins can interact each other through this registry.</p>
<a name="Writeyourfirstplugin"></a>
<h2>Write your first plugin</h2>
<p>Let's implement similar Jeka as previously but using plugins :</p>
<ul>
<li>Create a new project 'sample-plugins' as we did for 'sample1&quot;.</li>
<li>Remove all classes that has been created in 'jeka/def' : we don't need it for now.</li>
<li>Create a the following class inside 'jeka/def' : it could lie in a package or not.</li>
</ul>
<pre><code>@JkDoc(&quot;Provide command and option to display url content on the console&quot;)
public class JkPluginWebReader extends JkPlugin {

    @JkDoc(&quot;The url to display content.&quot;)
    public String url = &quot;https://www.google.com/&quot;;

    protected JkPluginWebReader(JkClass commands) {
        super(commands);
    }

    @JkDoc(&quot;Display source cotent of the url option on the console.&quot;)
    public void displayContent() throws MalformedURLException {
        String content = JkUtilsIO.read(new URL(url));
        System.out.println(content);
    }

}
</code></pre>
<ul>
<li>Execute <code>jeka help</code> in the console at the root of the project. At the end of the output your plugin should be
mentioned :</li>
</ul>
<pre><code>Available plugins in classpath : eclipse, eclipsePath, git, intellij, jacoco, java, pgp, pom, repo, scaffold, sonar, war, webReader.
</code></pre>
<p>Jeka has discovered automatically your plugin called 'webReader'. For this your plugin class must follow 3 requirements :</p>
<ul>
<li>be <code>public</code></li>
<li>extend <code>JkPlugin</code></li>
<li>having a name starting with 'JkPlugin' : plugin names are inferred from their class name</li>
</ul>
<p>Now you can execute <code>jeka webReader#help</code> to display which options and commands are available on this plugin.</p>
<p>To execute <code>displayContent</code> command : <code>jeka webReader#displayContent -webReader#url=https://twitter.com</code>.</p>
<p>You don't need to have a <em>Jeka class</em> defined in <em>jeka/def</em>. By default Jeka uses <code>dev.jeka.core.tool.JkClass</code>.</p>
<a name="Whatdidhappenedbehindthescene?"></a>
<h2>What did happened behind the scene ?</h2>
<p>Mentioning <code>webReader#</code> on the command line has instantiated <em>JkPluginWebReader</em> class, attaching it to the current <em>Jeka class</em> instance.</p>
<p>Mentioning <code>webReader#displayContent -webReader#url=https://twitter.com</code>  has injected the url value and invoke
<code>JkPluginWebReader#displayContent</code> method on the instance plugin.
This mechanism is similar to options/commands existing on <em>Jeka class</em>.</p>
<a name="ConfigurepluginswithintheJekaclass"></a>
<h2>Configure plugins within the Jeka class</h2>
<p>You may need to configure default options on plugins and invoke them from the <em>Jeka classes</em> without specifying
everything from the command line.</p>
<p>For such create a <em>Jeka class</em> within the same project and declare the plugin as below. In the <em>Jeka class</em> constructor
you can redefine plugin state as its default field values.</p>
<pre><code>public class MyCommands extends JkClass {

    private final JkPluginWebReader webReaderPlugin = getPlugin(JkPluginWebReader.class);

    MyCommands() {
        webReaderPlugin.url = &quot;https://twitter.com&quot;;  // define a new default url
    }

    public void show() throws MalformedURLException {
        webReaderPlugin.displayContent();
    }

}
</code></pre>
<p>Now, if you execute <code>jeka webReader#help</code> you'll notice that the default <code>url</code> value is now the one defined above.</p>
<p>You can also use <code>jeka show</code> as a shorthand for <code>jeka webReader#displayContent</code>.</p>
<p>Note : You can also configure plugin by overriding <code>JkClass@setup</code> methods. In this case
the values set here will override the ones provided by command line.</p>
<a name="Configure/Enhanceapluginfromanotherone"></a>
<h2>Configure/Enhance a plugin from another one</h2>
<p>It's quite common to have a plugin that acts as an enhancer of another one. For example <em>Jacoco</em> plugin enhance <em>Java</em>
plugin by adding test coverage when tests are run.</p>
<p>Of course this kind of mechanism is possible because <em>Java</em> plugin test feature has been designed to be extendable
but the idea is that a plugin can access or load any other plugins from its owning <em>Jeka class</em>.</p>
<p>Let's modify the webReader plugin in order it can allow the url be modified from the outside.</p>
<pre><code>public class JkPluginWebReader extends JkPlugin {

    @JkDoc(&quot;The url to display content.&quot;)
    public String url = &quot;https://www.google.com/&quot;;

    private UnaryOperator&lt;URL&gt; urlTransformer = url -&gt; url;

    protected JkPluginWebReader(JkClass Jeka) {
        super(Jeka);
    }

    @JkDoc(&quot;Fetch Google page and display its source on the console.&quot;)
    public void displayContent() throws MalformedURLException {
        URL effectiveUrl = urlTransformer.apply(new URL(url));
        System.out.println(&quot;Reading content from &quot; + effectiveUrl);
        String content = JkUtilsIO.read(effectiveUrl);
        System.out.println(content);
    }

    public void setUrlTransformer(UnaryOperator&lt;URL&gt; urlTransformer) {
        this.urlTransformer = urlTransformer;
    }

}
</code></pre>
<p>Now let's create a plugin HttpsIzer in <em>jeka/def</em> that forces the webReader plugin to use <em>https</em> protocol.</p>
<pre><code>public class JkPluginHttpsIzer extends JkPlugin {

    protected JkPluginHttpsIzer(JkClass Jeka) {
        super(commands);
    }

    @Override
    protected void activate() {
        boolean webReaderPresent = this.getJkClass().getPlugins().hasLoaded(JkPluginWebReader.class);
        if (!webReaderPresent) {
            return;
        }
        UnaryOperator&lt;URL&gt; urlTransformer = url -&gt; {
            try {
                return new URL(&quot;https&quot;, url.getHost(), url.getPort(), url.getFile());
            } catch (MalformedURLException e) {
                throw new IllegalArgumentException(e);
            }
        };
        JkPluginWebReader webReader = this.getJkClass().getPlugins().get(JkPluginWebReader.class);
        webReader.setUrlTransformer(urlTransformer);
    }
}
</code></pre>
<p>Now, if you execute <code>jeka webReader#displayContent -webReader#url=http://jeka.dev httpsIzer#</code> console will display :</p>
<pre><code>Reading content from https://jeka.dev
...
</code></pre>
<p><strong>Explanation:</strong> Adding <code>httpIzer#</code> instantiates and binds httpIzer plugin to its owning <em>Jeka class</em> instance.
During this process, <code>JkPlugin#activate</code> method is invoked. By default this method does nothing but as we have
overrode it in <code>JkPluginHttpsIzer</code>, it modifies the <code>JkPluginWebReader</code> plugin bound to the owning <em>Jeka</em> instance.</p>
<a name="Reuseapluginacrossprojects"></a>
<h2>Reuse a plugin across projects</h2>
<p>You can pack your plugin in a jar, publish it on a repository and reuse it any Jeka project. The prerequisite is to know
about building a Java project, which is covered in the next section.</p>
<a name="Develop"></a>
<h3>Develop</h3>
<p>For those just create a regular Java project and add Jeka as <em><strong>PROVIDED</strong></em> dependency.</p>
<pre><code>// Use same Jeka version both for building and compiling
project.addDependencies(JkDependencySet.of()
        .andFile(JkLocator.getJekaJarPath(), PROVIDED));
</code></pre>
<p>Code your plugin in <em>src/main/java</em> as you will do for any regular Java project. Of course you an use
any third party lib as you want but keep in mind that the more deps you have the more dependency issues
you may face with other plugins.</p>
<a name="Pack"></a>
<h2>Pack</h2>
<p>Execute <code>Java java#pack java#publish</code> to build your plugin project and deploy it to your default repository.</p>
<a name="Reuse"></a>
<h2>Reuse</h2>
<p>You have to import the jar containing the plugin you want to use.
As for any other jar, you can declare it in a <code>@JkDefClasspath</code> annotation.</p>
<pre><code>@JkDefClasspath(&quot;org.myorg:myjekaplugin:0.1&quot;)
class MyBuid extends JkClass {
}
</code></pre>
<p>If you don't have declared it in a <em>Jeka class</em> <code>@JkDefClasspath</code> annotation you can still invoke it from
the command line : <code>jeka @org.myorg:myjekaplugin:0.1 myPlugin#doSomething</code>.</p>
<a name="BuildaJavaproject"></a>
<h1>Build a Java project</h1>
<p>Now let's start more complicated tasks as building a Java project. It involves compilation, testing, packaging, dependency resolution, releasing, ...
There's many option to handle it in Jeka :</p>
<ul>
<li>Use low level API (similar to ANT tasks)</li>
<li>Use high level <em>JkJavaProject</em> API</li>
<li>Use Jeka Java Plugin</li>
</ul>
<p>The one you choose is a matter of taste, flexibility, verbosity, re-usability and integration with existing tools.</p>
<a name="BuildJavaprojectusinglow-levelAPI"></a>
<h2>Build Java project using low-level API</h2>
<p>This approach is quite similar to what developers do when they use ANT. It consists in writing explicit tasks to compile, make resources,
tests and produce jars using Jeka low-level API.</p>
<pre><code class="language-Java">import dev.jeka.core.api.depmanagement.*;
import dev.jeka.core.api.depmanagement.resolution.JkDependencyResolver;import dev.jeka.core.api.depmanagement.resolution.JkResolveResult;import dev.jeka.core.api.depmanagement.publication.JkScope;import dev.jeka.core.api.file.JkPathTree;
import dev.jeka.core.api.file.JkPathTreeSet;
import dev.jeka.core.api.file.JkResourceProcessor;
import dev.jeka.core.api.java.*;
import dev.jeka.core.api.java.testing.JkJavaTestClasses;
import dev.jeka.core.api.java.testing.JkUnit;
import dev.jeka.core.api.java.testing.JkUnit.JunitReportDetail;
import dev.jeka.core.tool.JkClass;
import dev.jeka.core.tool.JkDefClasspath;

import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

@JkDefClasspath(&quot;org.apache.httpcomponents:httpclient:jar:4.5.6&quot;)
public class AntStyleBuild extends JkClass {

    Path src = getBaseDir().resolve(&quot;src/main/javaPlugin&quot;);
    Path buildDir = getBaseDir().resolve(&quot;build/output&quot;);
    Path classDir = getOutputDir().resolve(&quot;classes&quot;);
    Path jarFile = getOutputDir().resolve(&quot;jar/&quot; + getBaseTree().getRoot().getFileName() + &quot;.jar&quot;);
    JkClasspath classpath;
    Path reportDir = buildDir.resolve(&quot;junitRreport&quot;);

    public void doDefault() {
        clean();
        run();
    }

    @Override
    protected void setup() {
       JkResolveResult depResolution = JkDependencyResolver.ofParent(JkRepo.ofMavenCentral()).resolve(JkDependencySet.of()
               .and(&quot;org.hibernate:hibernate-entitymanager:jar:5.4.2.Final&quot;)
               .and(&quot;junit:junit:4.11&quot;, JkScope.TEST)
       );
       classpath = JkClasspath.of(getBaseTree().andMatching(true,&quot;libs/**/*.jar&quot;).getFiles())
            .and(depResolution.getFiles());
    }

    public void compile() {
        JkJavaCompiler.ofJdk().compile(JkJavaCompileSpec.of()
                .setOutputDir(classDir)
                .setClasspath(classpath)
                .setSourceAndTargetVersion(JkJavaVersion.V8)
                .addSources(src));
        Map&lt;String, String&gt; varReplacement = new HashMap&lt;&gt;();
        varReplacement.put(&quot;${server.ip}&quot;, &quot;123.211.11.0&quot;);
        JkResourceProcessor.ofParent(JkPathTreeSet.of(src)).addInterpolator(&quot;**/*.properties&quot;, varReplacement)
                .generateTo(classDir, Charset.forName(&quot;UTF-8&quot;));
        JkPathTree.of(src).andMatching(false, &quot;**/*.javaPlugin&quot;).copyTo(classDir);
    }

    public void jar() {
        compile();
        JkManifest.ofEmpty().addMainClass(&quot;RunClass&quot;).writeToStandardLocation(classDir);
        JkPathTree.of(classDir).zipTo(jarFile);
    }

    public void javadoc() {
        JkJavadocProcessor.of(JkPathTreeSet.of(src), buildDir.resolve(&quot;javadoc&quot;)).process();
    }

    public void run() {
        jar();
        JkJavaProcess.of().withWorkingDir(jarFile.getParent())
            .andClasspath(classpath)
            .runJarSync(jarFile);
    }

    public void cleanBuild() {
        clean();
        jar();
    }

    public void junit() {
        jar();
        JkUnit.of().withForking()
        .withReportDir(reportDir)
        .withReport(JunitReportDetail.FULL)
        .run(JkJavaTestClasses.of(
                classpath.andPrepending(jarFile),
                JkPathTree.of(classDir).andMatching(true, &quot;**/*Test.class&quot;, &quot;*Test.class&quot;) ));
    }

}
</code></pre>
<a name="BuildJavaprojectusinghighlevelAPI"></a>
<h2>Build Java project using high level API</h2>
<p>Defining all tasks needed to build a project can be verbose and tedious. Therefore Jeka provides a higher level API
to build Java project. This API mainly consist in a <code>JkJavaProject</code> class defining the project structure, dependencies,
artifacts it produces and how they are produced.</p>
<p>Basically, A Java project build definition can stand in one single instance of <code>JkJavaProject</code>.
This class implements <code>JkArtifactProducer</code> which defines methods to produce artifacts as jar files, javadoc and any
other files you want to produces from the project build.</p>
<p>To avoid bloating <code>JkJavaProject</code> class, methods are splitted between <code>JkJavaProject</code> itself and
<code>JkJavaProjectMaker</code> classes. The first host methods relative to the project 'static' structure
(Name, version, layout, dependencies, Java version, default compilation options, manifest) and <em>maker</em> hosts methods
to produced/published artifacts (jar, source-jars, javadoc, ...).</p>
<p>The outstanding philosophy is that the <em>raison d'être</em> of a Java project is to produce and publish artifacts (artifact = file produced by a project build).
The <em>maker</em> holds the artifacts to produce and how to produce them.
By default, the production of the main artifact implies unit testing.</p>
<p>The following example shows how to build 2 projects, one depending on the other. If you are only interested of building
a standalone project, you can concentrate on the Foo project.</p>
<pre><code class="language-Java">JkJavaProject coreProject = JkJavaProject.of()
    .setBaseDir(Paths.get(&quot;../dev.jeka.core-samples&quot;))
     .getJarProduction().getDependencyManagement()
        .addDependencies(JkDependencySet.of()
                .and(&quot;junit:junit:4.13&quot;, JkScope.TEST)).__.__;

// A project depending on the first project + Guava
JkJavaProject dependerProject = JkJavaProject.of()
    .getJarProduction()
    .getDependencyManagement()
        .addDependencies(JkDependencySet.of()
            .and(&quot;com.google.guava:guava:22.0&quot;)
            .and(coreProject.toDependency())).__.__
    .getPublication()
        .setModuleId(&quot;mygroup:depender&quot;)
        .setVersion(JkVersion.of(&quot;1.0-SNAPSHOT&quot;)).__;
dependerProject.getPublication().getArtifactProducer().makeAllArtifacts();
dependerProject.getPublication().publish();       
</code></pre>
<a name="BuildJavaprojectusingJekaJavaplugin."></a>
<h2>Build Java project using Jeka Java plugin.</h2>
<p>The java plugin consists in holding a <code>JkJavaProject</code> instance with predefined methods that you can directly call from the command line.
It can also alter other loaded plugin instances in order they take in account of Java nature of the project.</p>
<p>Let's create a new project from scratch to illustrate it :</p>
<ol>
<li>Create the root directory of your project (here 'mygroup.myproject').</li>
<li>Execute <code>jeka scaffold#run java#</code> under this directory.
This will generate a project skeleton with the following build class at <em>[PROJECT DIR]/build/def/Build.java</em></li>
</ol>
<pre><code>mygroup.myproject
   + jeka             
      + def             &lt;-----  Java code that build your project goes here
         + Build.java   
      + output          &lt;---- Build artifacts are generated here
   + src
      + main
          + java        &lt;----- Your project java sources and resources for production go here
      + test
          + java        &lt;----- Your project java sources and resources for testing go here    
</code></pre>
<p>Explanation : <code>scaffold#run</code> invokes 'run' method on the 'scaffold' plugin.  <code>java#</code> forces the <code>java</code> plugin to be loaded. When loaded,
'java' plugin has the effect to instruct scaffold plugin extra actions for generating a Java project.</p>
<p>By default the project mimics Maven layout convention so sources are supposed to lie in <em>src/main/java</em>.</p>
<p>Below is the content of the generated build class. Guava and Junit are present only fo demo purpose. You can remove it safely and add
any dependency you need.</p>
<pre><code class="language-Java">import dev.jeka.core.api.depmanagement.JkDependencySet;
import dev.jeka.core.api.depmanagement.publication.JkScope;
import dev.jeka.core.tool.JkInit;
import dev.jeka.core.tool.JkClass;
import dev.jeka.core.tool.JkPluginJava;

class Build extends JkClass {

    final JkPluginJava java = getPlugin(JkPluginJava.class);

    /*
     * Configures plugins to be bound to this Jeka class. When this method is called, option
     * fields have already been injected from command line.
     */
    @Override
    protected void setup() {
        java.getProject()
            .getJarProduction()
                .getDependencyManagement()
                    .addDependencies(JkDependencySet.of()
                        .and(&quot;com.google.guava:guava:21.0&quot;)
                        .and(&quot;junit:junit:4.13&quot;, JkScope.TEST));
    }

    public static void main(String[] args) {
        JkInit.instanceOf(Build.class, args).javaPlugin.clean().pack();
    }
    
}
</code></pre>
<p>Execute <code>jeka java#info</code> to see an abstract of the project setup.</p>
<a name="Buildyourproject"></a>
<h2>Build your project</h2>
<ol>
<li>Edit the Build.java source file above. For example, you can add compile dependencies.</li>
<li>Just execute <code>jeka clean java#pack</code> under the project base directory. This will compile, run test and package your project in a jar file. You can also lauch the <code>main</code> method from your IDE.</li>
</ol>
<a name="Extrafunction"></a>
<h2>Extra function</h2>
<p>If you want to create jar along javadoc and sources without testing :
just execute <code>jeka clean java#pack -java#test</code>.</p>
<p>Explanation '-' prefix means that you want to set an option value. For example <code>-java#pack.sources=false</code> means that
<code>JkPluginJava.pack.sources</code> will be injected the <code>false</code> value.</p>
<p>You can also set it by default in the build class constructor :</p>
<pre><code class="language-Java">    protected Build() {
        java.tests.skip = true;
    }
</code></pre>
<a name="Explorefunctionsandoptionsprovidedout-of-thebox"></a>
<h2>Explore functions and options provided out-of-thebox</h2>
<p>Execute <code>jeka help</code> to display all what you can do from the command line for the current project. As told on the help screen,
you can execute <code>jeka aGivenPluginName#help</code> to display help on a specific plugin.
The list of available plugins on the Jeka classpath is displayed in help screen.</p>
</body>
</html>
