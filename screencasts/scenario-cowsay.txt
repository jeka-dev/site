
# Let's run a Java command-line application directly from its project source repo: https://github.com/jeka-dev/demo-cowsay
# This application is a Java port of 'cowsay' and is built with JeKa, which facilitates auto-run.
# We decide to run the version tagged as 0.0.3
jeka -r "https://github.com/jeka-dev/demo-cowsay#0.0.3" -p Hello JeKa
# The second run is much quicker, as the binaries are cached
jeka -r https://github.com/jeka-dev/demo-cowsay#0.0.3 -p Hello JeKa

# Let's create a shorthand in ~/.jeka/global.properties to ease usage
echo "jeka.cmd.cowsay=-r https://github.com/jeka-dev/demo-cowsay#0.0.3 -p" >> ~/.jeka/global.properties
fortune | jeka ::cowsay -f kitty

# Let JeKa produce a default Docker image for this application
jeka -r "https://github.com/jeka-dev/demo-cowsay#0.0.3" docker:build
# Run this image
docker run -it --rm -e PROGRAM_ARGS="Hello Docker" github.com_jeka-dev_demo-cowsay:0.0.3

# Only a few lines were needed by JeKa to build and make this project runnable.
# The jeka.properties file, where the Java version and build instructions are mentioned
cat ~/.jeka/cache/git/github.com_jeka-dev_demo-cowsay#0.0.3/jeka.properties
# The dependencies.txt file containing library dependencies
cat ~/.jeka/cache/git/github.com_jeka-dev_demo-cowsay#0.0.3/dependencies.txt

# This is the basis of JeKa's capabilities for running Java applications from remote sources
# JeKa works with any type of applications (Swing, Web-app, etc.) on Windows, Linux, macOS, and containers
# See other examples at https://github.com/jeka-dev/jeka#examples


------ clean dirs
rm -f ~/cowsay.cast && : > ~/.jeka/global.properties && rm -rf ~/.jeka/cache/jdks/graalvm-21 && rm -rf ~/.jeka/cache/git/github.com_jeka-dev_demo-cowsay#0.0.3 && clear

Recorded with asciinema
Start Recording : asciinema rec cowsay.cast
Stop recording  : ctrl + D
play Recording  : asciinema play cowsay.cast
share Recording : asciinema upload cowsay.cast
Embbed Recording: <script async id="asciicast-569727" src="https://asciinema.org/a/569727.js"></script>